--- src/vim.h
+++ src/vim.h
@@ -462,7 +462,8 @@ typedef unsigned long u8char_T;	    /* long should be 32 bits or more */
  * Check input method control.
  */
 #if defined(FEAT_XIM) || \
-    (defined(FEAT_GUI) && (defined(FEAT_MBYTE_IME) || defined(GLOBAL_IME)))
+    (defined(FEAT_GUI) && (defined(FEAT_MBYTE_IME) || defined(GLOBAL_IME))) || \
+    defined(FEAT_GUI_MAC)
 # define USE_IM_CONTROL
 #endif
 
--- src/gui_mac.c
+++ src/gui_mac.c
@@ -59,7 +59,31 @@ SInt32 gMacSystemVersion;
 
 #ifdef MACOS_CONVERT
 # define USE_CARBONKEYHANDLER
+
+int im_is_active = FALSE;
+int im_start_row = 0;
+int im_start_col = 0;
+
+#define NR_ELEMS(x)     (sizeof(x) / sizeof(x[0]))
+
+TSMDocumentID gTSMDocument;
+
+void im_on_window_switch(int active);
 static EventHandlerUPP keyEventHandlerUPP = NULL;
+static EventHandlerUPP winEventHandlerUPP = NULL;
+
+static pascal OSStatus gui_mac_handle_window_activate(
+        EventHandlerCallRef nextHandler, EventRef theEvent, void *data);
+
+static pascal OSStatus gui_mac_handle_text_input(
+        EventHandlerCallRef nextHandler, EventRef theEvent, void *data);
+
+static pascal OSStatus gui_mac_update_input_area(
+        EventHandlerCallRef nextHandler, EventRef theEvent);
+
+static pascal OSStatus gui_mac_unicode_key_event(
+        EventHandlerCallRef nextHandler, EventRef theEvent);
+
 #endif
 
 
@@ -137,7 +161,11 @@ static struct
 
 #ifdef MACOS_CONVERT
 # define USE_ATSUI_DRAWING
+int         p_macatsui_last;
 ATSUStyle   gFontStyle;
+#ifdef FEAT_MBYTE
+ATSUStyle   gWideFontStyle;
+#endif
 Boolean	    gIsFontFallbackSet;
 #endif
 
@@ -265,6 +293,12 @@ static void initialise_tabline(void);
 static WindowRef drawer = NULL; // TODO: put into gui.h
 #endif
 
+#ifdef USE_ATSUI_DRAWING
+void gui_mac_set_font_attributes(GuiFont font);
+void gui_mac_dispose_atsui_style();
+void gui_mac_create_atsu_style();
+#endif
+
 /*
  * ------------------------------------------------------------
  * Conversion Utility
@@ -1976,15 +2010,84 @@ gui_mac_doSuspendEvent(EventRecord *event)
  * Handle the key
  */
 #ifdef USE_CARBONKEYHANDLER
+    static pascal OSStatus
+gui_mac_handle_window_activate(
+        EventHandlerCallRef nextHandler,
+	EventRef theEvent, void *data)
+{
+    UInt32 eventClass = GetEventClass(theEvent);
+    UInt32 eventKind  = GetEventKind(theEvent);
+
+    if (eventClass == kEventClassWindow)
+    {
+        switch (eventKind)
+        {
+        case kEventWindowActivated:
+#if defined(USE_IM_CONTROL)
+            im_on_window_switch(TRUE);
+#endif
+            return noErr;
+
+        case kEventWindowDeactivated:
+#if defined(USE_IM_CONTROL)
+            im_on_window_switch(FALSE);
+#endif
+            return noErr;
+        }
+    }
+
+    return eventNotHandledErr;
+}
+
+    static pascal OSStatus 
+gui_mac_handle_text_input(
+	EventHandlerCallRef nextHandler,
+	EventRef theEvent, void *data)
+{
+    UInt32 eventClass = GetEventClass(theEvent);
+    UInt32 eventKind  = GetEventKind(theEvent);
+
+    if (eventClass != kEventClassTextInput)
+          return eventNotHandledErr;
+
+    if ((kEventTextInputUpdateActiveInputArea != eventKind) &&
+        (kEventTextInputUnicodeForKeyEvent    != eventKind) &&
+        (kEventTextInputOffsetToPos           != eventKind) &&
+        (kEventTextInputPosToOffset           != eventKind) &&
+        (kEventTextInputGetSelectedText       != eventKind))
+              return eventNotHandledErr;
+
+    switch (eventKind)
+    {
+    case kEventTextInputUpdateActiveInputArea:
+        return gui_mac_update_input_area(nextHandler, theEvent);
+    case kEventTextInputUnicodeForKeyEvent:
+        return gui_mac_unicode_key_event(nextHandler, theEvent);
+
+    case kEventTextInputOffsetToPos:
+    case kEventTextInputPosToOffset:
+    case kEventTextInputGetSelectedText:
+        break;
+    }
+    
+    return eventNotHandledErr;
+}
+
+    static pascal 
+OSStatus gui_mac_update_input_area(
+        EventHandlerCallRef nextHandler,
+	EventRef theEvent)
+{
+    return eventNotHandledErr;
+}
 
 static int dialog_busy = FALSE;	    /* TRUE when gui_mch_dialog() wants the keys */
 
 # define INLINE_KEY_BUFFER_SIZE 80
     static pascal OSStatus
-gui_mac_doKeyEventCarbon(
+gui_mac_unicode_key_event(
 	EventHandlerCallRef nextHandler,
-	EventRef theEvent,
-	void *data)
+	EventRef theEvent)
 {
     /* Multibyte-friendly key event handler */
     OSStatus	err = -1;
@@ -2000,7 +2103,7 @@ gui_mac_doKeyEventCarbon(
     char_u	*to = NULL;
     Boolean	isSpecial = FALSE;
     int		i;
-    EventRef keyEvent;
+    EventRef    keyEvent;
 
     /* Mask the mouse (as per user setting) */
     if (p_mh)
@@ -2832,7 +2935,6 @@ gui_mch_prepare(int *argc, char **argv)
 # else
     /* OSErr GetApplicationBundleFSSpec(FSSpecPtr theFSSpecPtr)
      * of TN2015
-     * This technic remove the ../Contents/MacOS/etc part
      */
     (void)GetCurrentProcess(&psn);
     /* if (err != noErr) return err; */
@@ -2933,10 +3035,9 @@ gui_mch_init(void)
     /* TODO: Move most of this stuff toward gui_mch_init */
     Rect	windRect;
     MenuHandle	pomme;
-    EventTypeSpec   eventTypeSpec;
     EventHandlerRef mouseWheelHandlerRef;
 #ifdef USE_CARBONKEYHANDLER
-    EventHandlerRef keyEventHandlerRef;
+    EventTypeSpec eventTypeSpec;
 #endif
     ControlRef rootControl;
 
@@ -3042,16 +3143,47 @@ gui_mch_init(void)
     }
 
 #ifdef USE_CARBONKEYHANDLER
-    eventTypeSpec.eventClass = kEventClassTextInput;
-    eventTypeSpec.eventKind = kEventUnicodeForKeyEvent;
-    keyEventHandlerUPP = NewEventHandlerUPP(gui_mac_doKeyEventCarbon);
-    if (noErr != InstallApplicationEventHandler(keyEventHandlerUPP, 1,
-		&eventTypeSpec, NULL, &keyEventHandlerRef))
+    InterfaceTypeList supportedServices = { kUnicodeDocument };
+    NewTSMDocument(1, supportedServices, &gTSMDocument, 0);
+
+    /* We don't support inline input yet, use input window by default */
+    UseInputWindow(gTSMDocument, TRUE);
+
+    /* Should we activate the document by default? */
+    // ActivateTSMDocument(gTSMDocument);
+
+    EventTypeSpec textEventTypes[] = {
+        { kEventClassTextInput, kEventTextInputUpdateActiveInputArea },
+        { kEventClassTextInput, kEventTextInputUnicodeForKeyEvent },
+        { kEventClassTextInput, kEventTextInputPosToOffset },
+        { kEventClassTextInput, kEventTextInputOffsetToPos },
+    };
+
+    keyEventHandlerUPP = NewEventHandlerUPP(gui_mac_handle_text_input);
+    if (noErr != InstallApplicationEventHandler(keyEventHandlerUPP, 
+                                                NR_ELEMS(textEventTypes),
+		                                textEventTypes, NULL, NULL))
     {
-	keyEventHandlerRef = NULL;
 	DisposeEventHandlerUPP(keyEventHandlerUPP);
 	keyEventHandlerUPP = NULL;
     }
+
+    EventTypeSpec windowEventTypes[] = {
+        { kEventClassWindow, kEventWindowActivated }, 
+        { kEventClassWindow, kEventWindowDeactivated }, 
+    };
+
+    /* Install window event handler to support TSMDocument activate and
+     * deactivate */
+    winEventHandlerUPP = NewEventHandlerUPP(gui_mac_handle_window_activate);
+    if (noErr != InstallWindowEventHandler(gui.VimWindow, 
+                                           winEventHandlerUPP, 
+                                           NR_ELEMS(windowEventTypes), 
+                                           windowEventTypes, NULL, NULL))
+    {
+        DisposeEventHandlerUPP(winEventHandlerUPP);
+	winEventHandlerUPP = NULL;
+    }
 #endif
 
 /*
@@ -3107,6 +3239,19 @@ gui_mch_open(void)
     return OK;
 }
 
+#ifdef USE_ATSUI_DRAWING
+    void
+gui_mac_dispose_atsui_style()
+{
+    if (p_macatsui && gFontStyle)
+	ATSUDisposeStyle(gFontStyle);
+#ifdef FEAT_MBYTE
+    if (p_macatsui && gWideFontStyle)
+	ATSUDisposeStyle(gWideFontStyle);
+#endif
+}
+#endif
+
     void
 gui_mch_exit(int rc)
 {
@@ -3122,8 +3267,13 @@ gui_mch_exit(int rc)
 	DisposeEventHandlerUPP(mouseWheelHandlerUPP);
 
 #ifdef USE_ATSUI_DRAWING
-    if (p_macatsui && gFontStyle)
-	ATSUDisposeStyle(gFontStyle);
+    gui_mac_dispose_atsui_style();
+#endif
+
+#ifdef USE_CARBONKEYHANDLER
+    FixTSMDocument(gTSMDocument);
+    DeactivateTSMDocument(gTSMDocument);
+    DeleteTSMDocument(gTSMDocument);
 #endif
 
     /* Exit to shell? */
@@ -3263,6 +3413,26 @@ gui_mac_select_font(char_u *font_name)
     return selected_font;
 }
 
+#ifdef USE_ATSUI_DRAWING
+    void 
+gui_mac_create_atsui_style()
+{
+    if (p_macatsui && gFontStyle == NULL)
+    {
+	if (ATSUCreateStyle(&gFontStyle) != noErr)
+	    gFontStyle = NULL;
+    }
+#ifdef FEAT_MBYTE
+    if (p_macatsui && gWideFontStyle == NULL)
+    {
+	if (ATSUCreateStyle(&gWideFontStyle) != noErr)
+	    gWideFontStyle = NULL;
+    }
+#endif
+
+    p_macatsui_last = p_macatsui;
+}
+#endif
 
 /*
  * Initialise vim to use the font with the given name.	Return FAIL if the font
@@ -3280,11 +3450,7 @@ gui_mch_init_font(char_u *font_name, int fontset)
     char_u	used_font_name[512];
 
 #ifdef USE_ATSUI_DRAWING
-    if (p_macatsui && gFontStyle == NULL)
-    {
-	if (ATSUCreateStyle(&gFontStyle) != noErr)
-	    gFontStyle = NULL;
-    }
+    gui_mac_create_atsui_style();
 #endif
 
     if (font_name == NULL)
@@ -3348,49 +3514,8 @@ gui_mch_init_font(char_u *font_name, int fontset)
     gui.char_height = font_info.ascent + font_info.descent + p_linespace;
 
 #ifdef USE_ATSUI_DRAWING
-    ATSUFontID			fontID;
-    Fixed			fontSize;
-    ATSStyleRenderingOptions	fontOptions;
-
     if (p_macatsui && gFontStyle)
-    {
-	fontID = font & 0xFFFF;
-	fontSize = Long2Fix(font >> 16);
-
-	/* No antialiasing by default (do not attempt to touch antialising
-	 * options on pre-Jaguar) */
-	fontOptions =
-	    (gMacSystemVersion >= 0x1020) ?
-	    kATSStyleNoAntiAliasing :
-	    kATSStyleNoOptions;
-
-	ATSUAttributeTag attribTags[] =
-	{
-	    kATSUFontTag, kATSUSizeTag, kATSUStyleRenderingOptionsTag,
-	    kATSUMaxATSUITagValue+1
-	};
-	ByteCount attribSizes[] =
-	{
-	    sizeof(ATSUFontID), sizeof(Fixed),
-	    sizeof(ATSStyleRenderingOptions), sizeof font
-	};
-	ATSUAttributeValuePtr attribValues[] =
-	{
-	    &fontID, &fontSize, &fontOptions, &font
-	};
-
-	/* Convert font id to ATSUFontID */
-	if (FMGetFontFromFontFamilyInstance(fontID, 0, &fontID, NULL) == noErr)
-	{
-	    if (ATSUSetAttributes(gFontStyle,
-			(sizeof attribTags)/sizeof(ATSUAttributeTag),
-			attribTags, attribSizes, attribValues) != noErr)
-	    {
-		ATSUDisposeStyle(gFontStyle);
-		gFontStyle = NULL;
-	    }
-	}
-    }
+	gui_mac_set_font_attributes(font);
 #endif
 
     return OK;
@@ -3447,6 +3572,68 @@ gui_mch_get_fontname(GuiFont font, char_u *name)
 }
 #endif
 
+#ifdef USE_ATSUI_DRAWING
+    void 
+gui_mac_set_font_attributes(GuiFont font)
+{
+    ATSUFontID	fontID;
+    Fixed	fontSize;
+    Fixed       fontWidth;
+    
+    fontID    = font & 0xFFFF;
+    fontSize  = Long2Fix(font >> 16);
+    fontWidth = Long2Fix(gui.char_width);
+
+    ATSUAttributeTag attribTags[] =
+    {
+        kATSUFontTag, kATSUSizeTag, kATSUImposeWidthTag, 
+        kATSUMaxATSUITagValue + 1
+    };
+
+    ByteCount attribSizes[] =
+    {
+        sizeof(ATSUFontID), sizeof(Fixed), sizeof(fontWidth), 
+        sizeof(font)
+    };
+
+    ATSUAttributeValuePtr attribValues[] =
+    {
+        &fontID, &fontSize, &fontWidth, &font
+    };
+
+    if (FMGetFontFromFontFamilyInstance(fontID, 0, &fontID, NULL) == noErr)
+    {
+        if (ATSUSetAttributes(gFontStyle,
+                    (sizeof attribTags) / sizeof(ATSUAttributeTag),
+                    attribTags, attribSizes, attribValues) != noErr)
+        {
+# ifndef NDEBUG
+            fprintf(stderr, "couldn't set font style\n");
+# endif
+            ATSUDisposeStyle(gFontStyle);
+            gFontStyle = NULL;
+        }
+
+#ifdef FEAT_MBYTE
+        if (has_mbyte)
+        {
+            /* FIXME: we should use a more mbyte sensitive way to support 
+             * wide font drawing */
+            fontWidth = Long2Fix(gui.char_width * 2);
+
+            if (ATSUSetAttributes(gWideFontStyle,
+                        (sizeof attribTags) / sizeof(ATSUAttributeTag),
+                        attribTags, attribSizes, attribValues) != noErr)
+            {
+                ATSUDisposeStyle(gWideFontStyle);
+                gWideFontStyle = NULL;
+            }
+        }
+#endif
+    }
+}
+#endif
+
 /*
  * Set the current text font.
  */
@@ -3456,66 +3643,22 @@ gui_mch_set_font(GuiFont font)
 #ifdef USE_ATSUI_DRAWING
     GuiFont			currFont;
     ByteCount			actualFontByteCount;
-    ATSUFontID			fontID;
-    Fixed			fontSize;
-    ATSStyleRenderingOptions	fontOptions;
 
     if (p_macatsui && gFontStyle)
     {
 	/* Avoid setting same font again */
-	if (ATSUGetAttribute(gFontStyle, kATSUMaxATSUITagValue+1, sizeof font,
-		    &currFont, &actualFontByteCount) == noErr &&
-		actualFontByteCount == (sizeof font))
+	if (ATSUGetAttribute(gFontStyle, kATSUMaxATSUITagValue + 1, sizeof(font),
+		             &currFont, &actualFontByteCount) == noErr &&
+	    actualFontByteCount == (sizeof font))
 	{
 	    if (currFont == font)
 		return;
 	}
 
-	fontID = font & 0xFFFF;
-	fontSize = Long2Fix(font >> 16);
-	/* Respect p_antialias setting only for wide font.
-	 * The reason for doing this at the moment is a bit complicated,
-	 * but it's mainly because a) latin (non-wide) aliased fonts
-	 * look bad in OS X 10.3.x and below (due to a bug in ATS), and
-	 * b) wide multibyte input does not suffer from that problem. */
-	/*fontOptions =
-	    (p_antialias && (font == gui.wide_font)) ?
-	    kATSStyleNoOptions : kATSStyleNoAntiAliasing;
-	*/
-	/*fontOptions = kATSStyleAntiAliasing;*/
-
-	ATSUAttributeTag attribTags[] =
-	{
-	    kATSUFontTag, kATSUSizeTag, kATSUStyleRenderingOptionsTag,
-	    kATSUMaxATSUITagValue+1
-	};
-	ByteCount attribSizes[] =
-	{
-	    sizeof(ATSUFontID), sizeof(Fixed),
-	    sizeof(ATSStyleRenderingOptions), sizeof font
-	};
-	ATSUAttributeValuePtr attribValues[] =
-	{
-	    &fontID, &fontSize, &fontOptions, &font
-	};
-
-	if (FMGetFontFromFontFamilyInstance(fontID, 0, &fontID, NULL) == noErr)
-	{
-	    if (ATSUSetAttributes(gFontStyle,
-			(sizeof attribTags)/sizeof(ATSUAttributeTag),
-			attribTags, attribSizes, attribValues) != noErr)
-	    {
-# ifndef NDEBUG
-		fprintf(stderr, "couldn't set font style\n");
-# endif
-		ATSUDisposeStyle(gFontStyle);
-		gFontStyle = NULL;
-	    }
-	}
-
+        gui_mac_set_font_attributes(font);
     }
 
-    if (p_macatsui && !gIsFontFallbackSet)
+    if (p_macatsui && ! gIsFontFallbackSet)
     {
 	/* Setup automatic font substitution. The user's guifontwide
 	 * is tried first, then the system tries other fonts. */
@@ -3536,7 +3679,9 @@ gui_mch_set_font(GuiFont font)
 			&fallbackFonts,
 			NULL) == noErr)
 	    {
-		ATSUSetFontFallbacks((sizeof fallbackFonts)/sizeof(ATSUFontID), &fallbackFonts, kATSUSequentialFallbacksPreferred);
+		ATSUSetFontFallbacks((sizeof fallbackFonts)/sizeof(ATSUFontID), 
+                                     &fallbackFonts, 
+                                     kATSUSequentialFallbacksPreferred);
 	    }
 /*
 	ATSUAttributeValuePtr fallbackValues[] = { };
@@ -3921,7 +4066,10 @@ draw_string_ATSUI(int row, int col, char_u *s, int len, int flags)
 
     /* - ATSUI automatically antialiases text (Someone)
      * - for some reason it does not work... (Jussi) */
-
+#ifdef MAC_ATSUI_DEBUG
+    fprintf(stderr, "row = %d, col = %d, len = %d: '%c'\n", 
+            row, col, len, len == 1 ? s[0] : ' ');
+#endif
     /*
      * When antialiasing we're using srcOr mode, we have to clear the block
      * before drawing the text.
@@ -3956,35 +4104,120 @@ draw_string_ATSUI(int row, int col, char_u *s, int len, int flags)
     }
 
     {
-	/* Use old-style, non-antialiased QuickDraw text rendering. */
 	TextMode(srcCopy);
 	TextFace(normal);
 
-    /*  SelectFont(hdc, gui.currFont); */
-
+        /*  SelectFont(hdc, gui.currFont); */
 	if (flags & DRAW_TRANSP)
 	{
 	    TextMode(srcOr);
 	}
 
 	MoveTo(TEXT_X(col), TEXT_Y(row));
-	ATSUTextLayout textLayout;
-
-	if (ATSUCreateTextLayoutWithTextPtr(tofree,
-		    kATSUFromTextBeginning, kATSUToTextEnd,
-		    utf16_len,
-		    (gFontStyle ? 1 : 0), &utf16_len,
-		    (gFontStyle ? &gFontStyle : NULL),
-		    &textLayout) == noErr)
+
+        if (gFontStyle && flags & DRAW_BOLD)
+        {
+            Boolean attValue = true;
+            ATSUAttributeTag attribTags[] = { kATSUQDBoldfaceTag };
+            ByteCount attribSizes[] = { sizeof(Boolean) };
+            ATSUAttributeValuePtr attribValues[] = { &attValue };
+            
+            ATSUSetAttributes(gFontStyle, 1, attribTags, attribSizes, attribValues);
+        }
+
+#ifdef FEAT_MBYTE
+	if (has_mbyte)
 	{
-	    ATSUSetTransientFontMatching(textLayout, TRUE);
+	    int n, width_in_cell, last_width_in_cell;
+            UniCharArrayOffset offset = 0;
+            UniCharCount yet_to_draw = 0;
+            ATSUTextLayout textLayout;
+            ATSUStyle      textStyle;
+            
+            last_width_in_cell = 1;
+            ATSUCreateTextLayout(&textLayout);
+            ATSUSetTextPointerLocation(textLayout, tofree, 
+                                       kATSUFromTextBeginning, 
+                                       kATSUToTextEnd, utf16_len);
+            /*
+            ATSUSetRunStyle(textLayout, gFontStyle, 
+                            kATSUFromTextBeginning, kATSUToTextEnd); */
 
-	    ATSUDrawText(textLayout,
-		    kATSUFromTextBeginning, kATSUToTextEnd,
-		    kATSUUseGrafPortPenLoc, kATSUUseGrafPortPenLoc);
+	    /* Compute the length in display cells. */
+	    for (n = 0; n < len; n += MB_BYTE2LEN(s[n]))
+            {
+                width_in_cell = (*mb_ptr2cells)(s + n);
+
+                /* probably we are switching from single byte character 
+                 * to multibyte characters (which requires more than one
+                 * cell to draw) */
+                if (width_in_cell != last_width_in_cell)
+                {
+#ifdef MAC_ATSUI_DEBUG
+                    fprintf(stderr, "\tn = %2d, (%d-%d), offset = %d, yet_to_draw = %d\n", 
+                            n, last_width_in_cell, width_in_cell, offset, yet_to_draw);
+#endif
+                    textStyle = last_width_in_cell > 1 ? gWideFontStyle : gFontStyle;
+
+                    ATSUSetRunStyle(textLayout, textStyle, offset, yet_to_draw);
+                    offset += yet_to_draw;
+                    yet_to_draw = 0;
+                    last_width_in_cell = width_in_cell;
+                }
+                
+                yet_to_draw++;
+            }
+            
+            if (yet_to_draw)
+            {
+#ifdef MAC_ATSUI_DEBUG
+                fprintf(stderr, "\tn = %2d, (%d-%d), offset = %d, yet_to_draw = %d\n", 
+                        n, last_width_in_cell, width_in_cell, offset, yet_to_draw);
+#endif
+                /* finish the rest style */
+                textStyle = width_in_cell > 1 ? gWideFontStyle : gFontStyle;
+                ATSUSetRunStyle(textLayout, textStyle, offset, kATSUToTextEnd);
+            }
 
-	    ATSUDisposeTextLayout(textLayout);
+            ATSUSetTransientFontMatching(textLayout, TRUE);
+            ATSUDrawText(textLayout,
+                         kATSUFromTextBeginning, kATSUToTextEnd,
+                         kATSUUseGrafPortPenLoc, kATSUUseGrafPortPenLoc);
+            ATSUDisposeTextLayout(textLayout);
 	}
+        else
+#endif
+        {
+            ATSUTextLayout textLayout;
+
+            if (ATSUCreateTextLayoutWithTextPtr(tofree,
+                        kATSUFromTextBeginning, kATSUToTextEnd,
+                        utf16_len,
+                        (gFontStyle ? 1 : 0), &utf16_len,
+                        (gFontStyle ? &gFontStyle : NULL),
+                        &textLayout) == noErr)
+            {
+                ATSUSetTransientFontMatching(textLayout, TRUE);
+
+                ATSUDrawText(textLayout,
+                        kATSUFromTextBeginning, kATSUToTextEnd,
+                        kATSUUseGrafPortPenLoc, kATSUUseGrafPortPenLoc);
+
+                ATSUDisposeTextLayout(textLayout);
+            }
+        }
+
+        /* drawing is done, now reset bold to normal */
+        if (gFontStyle && flags & DRAW_BOLD)
+        {
+            Boolean attValue = false;
+            
+            ATSUAttributeTag attribTags[] = { kATSUQDBoldfaceTag };
+            ByteCount attribSizes[] = { sizeof(Boolean) };
+            ATSUAttributeValuePtr attribValues[] = { &attValue };
+            
+            ATSUSetAttributes(gFontStyle, 1, attribTags, attribSizes, attribValues);
+        }
     }
 
     if (flags & DRAW_UNDERC)
@@ -3998,6 +4231,14 @@ draw_string_ATSUI(int row, int col, char_u *s, int len, int flags)
 gui_mch_draw_string(int row, int col, char_u *s, int len, int flags)
 {
 #if defined(USE_ATSUI_DRAWING)
+    /* switch from macatsui to nomacatsui */
+    if (p_macatsui == 0 && p_macatsui_last != 0)
+        gui_mac_dispose_atsui_style();
+    else
+    /* switch from nomacatsui to macatsui */
+    if (p_macatsui != 0 && p_macatsui_last == 0)
+        gui_mac_create_atsui_style();
+
     if (p_macatsui)
 	draw_string_ATSUI(row, col, s, len, flags);
     else
@@ -4228,12 +4469,13 @@ gui_mch_wait_for_chars(int wtime)
 	 */
 	/* TODO: reduce wtime accordinly???  */
 	if (wtime > -1)
-	    sleeppyTick = 60*wtime/1000;
+	    sleeppyTick = 60 * wtime / 1000;
 	else
 	    sleeppyTick = 32767;
+
 	if (WaitNextEventWrp(mask, &event, sleeppyTick, dragRgn))
 	{
-		gui_mac_handle_event(&event);
+	    gui_mac_handle_event(&event);
 	    if (input_available())
 	    {
 		allow_scrollbar = FALSE;
@@ -6031,7 +6273,7 @@ char_u *FullPathFromFSSpec_save(FSSpec file)
 #endif
 }
 
-#if defined(USE_IM_CONTROL) || defined(PROTO)
+#if (defined(USE_IM_CONTROL) || defined(PROTO)) && defined(USE_CARBONKEYHANDLER)
 /*
  * Input Method Control functions.
  */
@@ -6043,6 +6285,68 @@ char_u *FullPathFromFSSpec_save(FSSpec file)
 im_set_position(int row, int col)
 {
     /* TODO: Implement me! */
+    im_start_row = row;
+    im_start_col = col;
+}
+
+ScriptLanguageRecord gTSLWindow;
+ScriptLanguageRecord gTSLInsert;
+ScriptLanguageRecord gTSLDefault = { 0, 0 };
+
+Component            gTSCWindow;
+Component            gTSCInsert;
+Component            gTSCDefault;
+
+int                  im_initialized = 0;
+
+    void 
+im_on_window_switch(int active)
+{
+    ScriptLanguageRecord *slptr = NULL;
+    OSStatus err;
+
+    if (! gui.in_use)
+        return;
+
+    if (im_initialized == 0)
+    {
+        im_initialized = 1;
+
+        /* save default TSM component (should be U.S.) to default */
+        GetDefaultInputMethodOfClass(&gTSCDefault, &gTSLDefault,
+                                     kKeyboardInputMethodClass);
+    }
+
+    if (active == TRUE)
+    {
+        im_is_active = TRUE;
+        ActivateTSMDocument(gTSMDocument);
+        slptr = &gTSLWindow;
+
+        if (slptr)
+        {
+            err = SetDefaultInputMethodOfClass(gTSCWindow, slptr,
+                                               kKeyboardInputMethodClass);
+            if (err == noErr)
+                err = SetTextServiceLanguage(slptr);
+
+            if (err == noErr)
+                KeyScript(slptr->fScript | smKeyForceKeyScriptMask);
+        }
+    }
+    else
+    {
+        err = GetTextServiceLanguage(&gTSLWindow);
+        if (err == noErr)
+            slptr = &gTSLWindow;
+
+        if (slptr)
+            GetDefaultInputMethodOfClass(&gTSCWindow, slptr,
+                                         kKeyboardInputMethodClass);
+
+        im_is_active = FALSE;
+        DeactivateTSMDocument(gTSMDocument);
+    }
 }
 
 /*
@@ -6051,7 +6355,57 @@ im_set_position(int row, int col)
     void
 im_set_active(int active)
 {
-    KeyScript(active ? smKeySysScript : smKeyRoman);
+    ScriptLanguageRecord *slptr = NULL;
+    OSStatus err;
+
+    if (! gui.in_use)
+        return;
+
+    if (im_initialized == 0)
+    {
+        im_initialized = 1;
+
+        /* save default TSM component (should be U.S.) to default */
+        GetDefaultInputMethodOfClass(&gTSCDefault, &gTSLDefault,
+                                     kKeyboardInputMethodClass);
+    }
+
+    if (active == TRUE)
+    {
+        im_is_active = TRUE;
+        ActivateTSMDocument(gTSMDocument);
+        slptr = &gTSLInsert;
+
+        if (slptr)
+        {
+            err = SetDefaultInputMethodOfClass(gTSCInsert, slptr,
+                                               kKeyboardInputMethodClass);
+            if (err == noErr)
+                err = SetTextServiceLanguage(slptr);
+
+            if (err == noErr)
+                KeyScript(slptr->fScript | smKeyForceKeyScriptMask);
+        }
+    }
+    else
+    {
+        err = GetTextServiceLanguage(&gTSLInsert);
+        if (err == noErr)
+            slptr = &gTSLInsert;
+
+        if (slptr)
+            GetDefaultInputMethodOfClass(&gTSCInsert, slptr,
+                                         kKeyboardInputMethodClass);
+
+        /* restore to default when switch to normal mode, so than we could
+         * enter commands easier */
+        SetDefaultInputMethodOfClass(gTSCDefault, &gTSLDefault,
+                                     kKeyboardInputMethodClass);
+        SetTextServiceLanguage(&gTSLDefault);
+
+        im_is_active = FALSE;
+        DeactivateTSMDocument(gTSMDocument);
+    }
 }
 
 /*
@@ -6060,9 +6414,10 @@ im_set_active(int active)
     int
 im_get_status(void)
 {
-    SInt32 script = GetScriptManagerVariable(smKeyScript);
-    return (script != smRoman
-	    && script == GetScriptManagerVariable(smSysScript)) ? 1 : 0;
+    if (! gui.in_use)
+        return 0;
+
+    return im_is_active;
 }
 
 #endif /* defined(USE_IM_CONTROL) || defined(PROTO) */
