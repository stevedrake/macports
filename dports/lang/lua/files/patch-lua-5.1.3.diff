diff -c -r lua-5.1.3/src/lapi.c lua-5.1.3-patched/src/lapi.c
*** ./src/lapi.c	Thu Jan  3 13:20:39 2008
--- ./src/lapi.c	Thu Feb 14 14:46:39 2008
***************
*** 1,5 ****
  /*
! ** $Id: lapi.c,v 2.55.1.3 2008/01/03 15:20:39 roberto Exp $
  ** Lua API
  ** See Copyright Notice in lua.h
  */
--- 1,5 ----
  /*
! ** $Id: lapi.c,v 2.55.1.4 2008/02/14 16:46:39 roberto Exp $
  ** Lua API
  ** See Copyright Notice in lua.h
  */
***************
*** 93,107 ****
  
  
  LUA_API int lua_checkstack (lua_State *L, int size) {
!   int res;
    lua_lock(L);
!   if ((L->top - L->base + size) > LUAI_MAXCSTACK)
      res = 0;  /* stack overflow */
!   else {
      luaD_checkstack(L, size);
      if (L->ci->top < L->top + size)
        L->ci->top = L->top + size;
-     res = 1;
    }
    lua_unlock(L);
    return res;
--- 93,106 ----
  
  
  LUA_API int lua_checkstack (lua_State *L, int size) {
!   int res = 1;
    lua_lock(L);
!   if (size > LUAI_MAXCSTACK || (L->top - L->base + size) > LUAI_MAXCSTACK)
      res = 0;  /* stack overflow */
!   else if (size > 0) {
      luaD_checkstack(L, size);
      if (L->ci->top < L->top + size)
        L->ci->top = L->top + size;
    }
    lua_unlock(L);
    return res;
diff -c -r lua-5.1.3/src/lbaselib.c lua-5.1.3-patched/src/lbaselib.c
*** ./src/lbaselib.c	Sun Jan 20 11:53:22 2008
--- ./src/lbaselib.c	Thu Feb 14 14:46:22 2008
***************
*** 1,5 ****
  /*
! ** $Id: lbaselib.c,v 1.191.1.4 2008/01/20 13:53:22 roberto Exp $
  ** Basic library
  ** See Copyright Notice in lua.h
  */
--- 1,5 ----
  /*
! ** $Id: lbaselib.c,v 1.191.1.6 2008/02/14 16:46:22 roberto Exp $
  ** Basic library
  ** See Copyright Notice in lua.h
  */
***************
*** 344,353 ****
    luaL_checktype(L, 1, LUA_TTABLE);
    i = luaL_optint(L, 2, 1);
    e = luaL_opt(L, luaL_checkint, 3, luaL_getn(L, 1));
    n = e - i + 1;  /* number of elements */
!   if (n <= 0) return 0;  /* empty range */
!   luaL_checkstack(L, n, "table too big to unpack");
!   for (; i<=e; i++)  /* push arg[i...e] */
      lua_rawgeti(L, 1, i);
    return n;
  }
--- 344,355 ----
    luaL_checktype(L, 1, LUA_TTABLE);
    i = luaL_optint(L, 2, 1);
    e = luaL_opt(L, luaL_checkint, 3, luaL_getn(L, 1));
+   if (i > e) return 0;  /* empty range */
    n = e - i + 1;  /* number of elements */
!   if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */
!     return luaL_error(L, "too many results to unpack");
!   lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */
!   while (i++ < e)  /* push arg[i + 1...e] */
      lua_rawgeti(L, 1, i);
    return n;
  }
***************
*** 526,532 ****
    status = lua_resume(co, narg);
    if (status == 0 || status == LUA_YIELD) {
      int nres = lua_gettop(co);
!     if (!lua_checkstack(L, nres))
        luaL_error(L, "too many results to resume");
      lua_xmove(co, L, nres);  /* move yielded values */
      return nres;
--- 528,534 ----
    status = lua_resume(co, narg);
    if (status == 0 || status == LUA_YIELD) {
      int nres = lua_gettop(co);
!     if (!lua_checkstack(L, nres + 1))
        luaL_error(L, "too many results to resume");
      lua_xmove(co, L, nres);  /* move yielded values */
      return nres;
diff -c -r lua-5.1.3/src/ldebug.c lua-5.1.3-patched/src/ldebug.c
*** ./src/ldebug.c	Fri Dec 28 13:32:23 2007
--- ./src/ldebug.c	Fri Apr  4 12:47:57 2008
***************
*** 1,5 ****
  /*
! ** $Id: ldebug.c,v 2.29.1.3 2007/12/28 15:32:23 roberto Exp $
  ** Debug Interface
  ** See Copyright Notice in lua.h
  */
--- 1,5 ----
  /*
! ** $Id: ldebug.c,v 2.29.1.5 2008/04/04 15:47:57 roberto Exp $
  ** Debug Interface
  ** See Copyright Notice in lua.h
  */
***************
*** 275,286 ****
  
  static int precheck (const Proto *pt) {
    check(pt->maxstacksize <= MAXSTACK);
!   lua_assert(pt->numparams+(pt->is_vararg & VARARG_HASARG) <= pt->maxstacksize);
!   lua_assert(!(pt->is_vararg & VARARG_NEEDSARG) ||
                (pt->is_vararg & VARARG_HASARG));
    check(pt->sizeupvalues <= pt->nups);
    check(pt->sizelineinfo == pt->sizecode || pt->sizelineinfo == 0);
!   check(GET_OPCODE(pt->code[pt->sizecode-1]) == OP_RETURN);
    return 1;
  }
  
--- 275,286 ----
  
  static int precheck (const Proto *pt) {
    check(pt->maxstacksize <= MAXSTACK);
!   check(pt->numparams+(pt->is_vararg & VARARG_HASARG) <= pt->maxstacksize);
!   check(!(pt->is_vararg & VARARG_NEEDSARG) ||
                (pt->is_vararg & VARARG_HASARG));
    check(pt->sizeupvalues <= pt->nups);
    check(pt->sizelineinfo == pt->sizecode || pt->sizelineinfo == 0);
!   check(pt->sizecode > 0 && GET_OPCODE(pt->code[pt->sizecode-1]) == OP_RETURN);
    return 1;
  }
  
***************
*** 346,354 ****
            int dest = pc+1+b;
            check(0 <= dest && dest < pt->sizecode);
            if (dest > 0) {
!             /* cannot jump to a setlist count */
!             Instruction d = pt->code[dest-1];
!             check(!(GET_OPCODE(d) == OP_SETLIST && GETARG_C(d) == 0));
            }
          }
          break;
--- 346,363 ----
            int dest = pc+1+b;
            check(0 <= dest && dest < pt->sizecode);
            if (dest > 0) {
!             int j;
!             /* check that it does not jump to a setlist count; this
!                is tricky, because the count from a previous setlist may
!                have the same value of an invalid setlist; so, we must
!                go all the way back to the first of them (if any) */
!             for (j = 0; j < dest; j++) {
!               Instruction d = pt->code[dest-1];
!               if (!(GET_OPCODE(d) == OP_SETLIST && GETARG_C(d) == 0)) break;
!             }
!             /* if 'j' is even, previous value is not a setlist (even if
!                it looks like one) */
!             check((j&1) == 0);
            }
          }
          break;
***************
*** 363,369 ****
      }
      switch (op) {
        case OP_LOADBOOL: {
!         check(c == 0 || pc+2 < pt->sizecode);  /* check its jump */
          break;
        }
        case OP_LOADNIL: {
--- 372,382 ----
      }
      switch (op) {
        case OP_LOADBOOL: {
!         if (c == 1) {  /* does it jump? */
!           check(pc+2 < pt->sizecode);  /* check its jump */
!           check(GET_OPCODE(pt->code[pc+1]) != OP_SETLIST ||
!                 GETARG_C(pt->code[pc+1]) != 0);
!         }
          break;
        }
        case OP_LOADNIL: {
***************
*** 428,434 ****
        }
        case OP_SETLIST: {
          if (b > 0) checkreg(pt, a + b);
!         if (c == 0) pc++;
          break;
        }
        case OP_CLOSURE: {
--- 441,450 ----
        }
        case OP_SETLIST: {
          if (b > 0) checkreg(pt, a + b);
!         if (c == 0) {
!           pc++;
!           check(pc < pt->sizecode - 1);
!         }
          break;
        }
        case OP_CLOSURE: {
diff -c -r lua-5.1.3/src/ltablib.c lua-5.1.3-patched/src/ltablib.c
*** ./src/ltablib.c	Fri Dec 28 13:32:23 2007
--- ./src/ltablib.c	Thu Feb 14 14:46:58 2008
***************
*** 1,5 ****
  /*
! ** $Id: ltablib.c,v 1.38.1.2 2007/12/28 15:32:23 roberto Exp $
  ** Library for Table Manipulation
  ** See Copyright Notice in lua.h
  */
--- 1,5 ----
  /*
! ** $Id: ltablib.c,v 1.38.1.3 2008/02/14 16:46:58 roberto Exp $
  ** Library for Table Manipulation
  ** See Copyright Notice in lua.h
  */
***************
*** 132,137 ****
--- 132,146 ----
  }
  
  
+ static void addfield (lua_State *L, luaL_Buffer *b, int i) {
+   lua_rawgeti(L, 1, i);
+   if (!lua_isstring(L, -1))
+     luaL_error(L, "invalid value (%s) at index %d in table for "
+                   LUA_QL("concat"), luaL_typename(L, -1), i);
+     luaL_addvalue(b);
+ }
+ 
+ 
  static int tconcat (lua_State *L) {
    luaL_Buffer b;
    size_t lsep;
***************
*** 141,153 ****
    i = luaL_optint(L, 3, 1);
    last = luaL_opt(L, luaL_checkint, 4, luaL_getn(L, 1));
    luaL_buffinit(L, &b);
!   for (; i <= last; i++) {
!     lua_rawgeti(L, 1, i);
!     luaL_argcheck(L, lua_isstring(L, -1), 1, "table contains non-strings");
!     luaL_addvalue(&b);
!     if (i != last)
!       luaL_addlstring(&b, sep, lsep);
    }
    luaL_pushresult(&b);
    return 1;
  }
--- 150,161 ----
    i = luaL_optint(L, 3, 1);
    last = luaL_opt(L, luaL_checkint, 4, luaL_getn(L, 1));
    luaL_buffinit(L, &b);
!   for (; i < last; i++) {
!     addfield(L, &b, i);
!     luaL_addlstring(&b, sep, lsep);
    }
+   if (i == last)  /* add last value (if interval was not empty) */
+     addfield(L, &b, i);
    luaL_pushresult(&b);
    return 1;
  }
diff -c -r lua-5.1.3/src/luaconf.h lua-5.1.3-patched/src/luaconf.h
*** ./src/luaconf.h	Fri Jan 18 15:07:48 2008
--- ./src/luaconf.h	Mon Feb 11 14:25:08 2008
***************
*** 1,5 ****
  /*
! ** $Id: luaconf.h,v 1.82.1.6 2008/01/18 17:07:48 roberto Exp $
  ** Configuration file for Lua
  ** See Copyright Notice in lua.h
  */
--- 1,5 ----
  /*
! ** $Id: luaconf.h,v 1.82.1.7 2008/02/11 16:25:08 roberto Exp $
  ** Configuration file for Lua
  ** See Copyright Notice in lua.h
  */
***************
*** 440,449 ****
  @* can use.
  ** CHANGE it if you need lots of (Lua) stack space for your C
  ** functions. This limit is arbitrary; its only purpose is to stop C
! ** functions to consume unlimited stack space.
  */
! #define LUAI_MCS_AUX	((int)(INT_MAX / (4*sizeof(LUA_NUMBER))))
! #define LUAI_MAXCSTACK	(LUAI_MCS_AUX > SHRT_MAX ? SHRT_MAX : LUAI_MCS_AUX)
  
  
  
--- 440,449 ----
  @* can use.
  ** CHANGE it if you need lots of (Lua) stack space for your C
  ** functions. This limit is arbitrary; its only purpose is to stop C
! ** functions to consume unlimited stack space. (must be smaller than
! ** -LUA_REGISTRYINDEX)
  */
! #define LUAI_MAXCSTACK	8000
  
  
  
diff -c -r lua-5.1.3/src/lundump.c lua-5.1.3-patched/src/lundump.c
*** ./src/lundump.c	Fri Jan 18 14:39:11 2008
--- ./src/lundump.c	Fri Apr  4 16:51:41 2008
***************
*** 1,5 ****
  /*
! ** $Id: lundump.c,v 2.7.1.2 2008/01/18 16:39:11 roberto Exp $
  ** load precompiled Lua chunks
  ** See Copyright Notice in lua.h
  */
--- 1,5 ----
  /*
! ** $Id: lundump.c,v 2.7.1.4 2008/04/04 19:51:41 roberto Exp $
  ** load precompiled Lua chunks
  ** See Copyright Notice in lua.h
  */
***************
*** 48,54 ****
  static void LoadBlock(LoadState* S, void* b, size_t size)
  {
   size_t r=luaZ_read(S->Z,b,size);
-  UNUSED(r);
   IF (r!=0, "unexpected end");
  }
  
--- 48,53 ----
***************
*** 115,121 ****
     	setnilvalue(o);
  	break;
     case LUA_TBOOLEAN:
!    	setbvalue(o,LoadChar(S));
  	break;
     case LUA_TNUMBER:
  	setnvalue(o,LoadNumber(S));
--- 114,120 ----
     	setnilvalue(o);
  	break;
     case LUA_TBOOLEAN:
!    	setbvalue(o,LoadChar(S)!=0);
  	break;
     case LUA_TNUMBER:
  	setnvalue(o,LoadNumber(S));
***************
*** 161,167 ****
  
  static Proto* LoadFunction(LoadState* S, TString* p)
  {
!  Proto* f=luaF_newproto(S->L);
   setptvalue2s(S->L,S->L->top,f); incr_top(S->L);
   f->source=LoadString(S); if (f->source==NULL) f->source=p;
   f->linedefined=LoadInt(S);
--- 160,168 ----
  
  static Proto* LoadFunction(LoadState* S, TString* p)
  {
!  Proto* f;
!  if (++S->L->nCcalls > LUAI_MAXCCALLS) error(S,"code too deep");
!  f=luaF_newproto(S->L);
   setptvalue2s(S->L,S->L->top,f); incr_top(S->L);
   f->source=LoadString(S); if (f->source==NULL) f->source=p;
   f->linedefined=LoadInt(S);
***************
*** 175,180 ****
--- 176,182 ----
   LoadDebug(S,f);
   IF (!luaG_checkcode(f), "bad code");
   S->L->top--;
+  S->L->nCcalls--;
   return f;
  }
  
