--- asmcomp/emitaux.ml.orig	2009-01-27 02:06:10.000000000 +0900
+++ asmcomp/emitaux.ml	2009-10-01 20:03:55.000000000 +0900
@@ -10,7 +10,7 @@
 (*                                                                     *)
 (***********************************************************************)
 
-(* $Id: emitaux.ml,v 1.12.12.1 2009/01/26 17:06:10 xleroy Exp $ *)
+(* $Id: emitaux.ml,v 1.12.12.2 2009-07-15 12:14:39 xleroy Exp $ *)
 
 (* Common functions for emitting assembly code *)
 
@@ -93,6 +93,27 @@
    done;
    if !pos > 0 then emit_char '\n'
 
+(* PR#4813: assemblers do strange things with float literals indeed,
+   so we convert to IEEE representation ourselves and emit float
+   literals as 32- or 64-bit integers. *)
+
+let emit_float64_directive directive f =
+  let x = Int64.bits_of_float (float_of_string f) in
+  emit_printf "\t%s\t0x%Lx\n" directive x
+
+let emit_float64_split_directive directive f =
+  let x = Int64.bits_of_float (float_of_string f) in
+  let lo = Int64.logand x 0xFFFF_FFFFL
+  and hi = Int64.shift_right_logical x 32 in
+  emit_printf "\t%s\t0x%Lx, 0x%Lx\n"
+    directive
+    (if Arch.big_endian then hi else lo)
+    (if Arch.big_endian then lo else hi)
+
+let emit_float32_directive directive f =
+  let x = Int32.bits_of_float (float_of_string f) in
+  emit_printf "\t%s\t0x%lx\n" directive x
+
 (* Record live pointers at call points *)
 
 type frame_descr =
