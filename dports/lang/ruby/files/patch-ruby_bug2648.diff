diff -ur ../ruby-1.8.7-p249.org/eval.c ./eval.c
--- ../ruby-1.8.7-p249.org/eval.c	2009-12-21 17:11:42.000000000 +0900
+++ ./eval.c	2010-01-27 20:59:35.000000000 +0900
@@ -12245,7 +12245,9 @@
     return th;
 }
 
+#if defined(HAVE_SETITIMER) || defined(_THREAD_SAFE)
 static int thread_init;
+#endif
 
 #if defined(POSIX_SIGNAL)
 #define CATCH_VTALRM() posix_signal(SIGVTALRM, catch_timer)
@@ -12292,6 +12294,8 @@
     pthread_t thread;
 } time_thread = {PTHREAD_COND_INITIALIZER, PTHREAD_MUTEX_INITIALIZER};
 
+static int timer_stopping;
+
 #define safe_mutex_lock(lock) \
     pthread_mutex_lock(lock); \
     pthread_cleanup_push((void (*)_((void *)))pthread_mutex_unlock, lock)
@@ -12316,6 +12320,9 @@
 #define WAIT_FOR_10MS() \
     pthread_cond_timedwait(&running->cond, &running->lock, get_ts(&to, PER_NANO/100))
     while ((err = WAIT_FOR_10MS()) == EINTR || err == ETIMEDOUT) {
+	if (timer_stopping)
+	    break;
+
 	if (!rb_thread_critical) {
 	    rb_thread_pending = 1;
 	    if (rb_trap_immediate) {
@@ -12343,7 +12350,9 @@
     safe_mutex_lock(&time_thread.lock);
     if (pthread_create(&time_thread.thread, 0, thread_timer, args) == 0) {
 	thread_init = 1;
+#if !defined(__NetBSD__) && !defined(__APPLE__)
 	pthread_atfork(0, 0, rb_thread_stop_timer);
+#endif
 	pthread_cond_wait(&start, &time_thread.lock);
     }
     pthread_cleanup_pop(1);
@@ -12354,10 +12363,12 @@
 {
     if (!thread_init) return;
     safe_mutex_lock(&time_thread.lock);
+    timer_stopping = 1;
     pthread_cond_signal(&time_thread.cond);
     thread_init = 0;
     pthread_cleanup_pop(1);
     pthread_join(time_thread.thread, NULL);
+    timer_stopping = 0;
 }
 #elif defined(HAVE_SETITIMER)
 static void
Only in .: eval.c.orig
diff -ur ../ruby-1.8.7-p249.org/io.c ./io.c
--- ../ruby-1.8.7-p249.org/io.c	2009-11-25 17:45:13.000000000 +0900
+++ ./io.c	2010-01-27 20:59:35.000000000 +0900
@@ -3245,6 +3245,9 @@
     }
 
   retry:
+#if defined(__NetBSD__) || defined(__APPLE__)
+    rb_thread_stop_timer();
+#endif
     switch ((pid = fork())) {
       case 0:			/* child */
 	if (modef & FMODE_READABLE) {
@@ -3272,11 +3275,17 @@
 		    ruby_sourcefile, ruby_sourceline, pname);
 	    _exit(127);
 	}
+#if defined(__NetBSD__) || defined(__APPLE__)
+	rb_thread_start_timer();
+#endif
 	rb_io_synchronized(RFILE(orig_stdout)->fptr);
 	rb_io_synchronized(RFILE(orig_stderr)->fptr);
 	return Qnil;
 
       case -1:			/* fork failed */
+#if defined(__NetBSD__) || defined(__APPLE__)
+	rb_thread_start_timer();
+#endif
 	if (errno == EAGAIN) {
 	    rb_thread_sleep(1);
 	    goto retry;
@@ -3297,6 +3306,9 @@
 	break;
 
       default:			/* parent */
+#if defined(__NetBSD__) || defined(__APPLE__)
+	rb_thread_start_timer();
+#endif
 	if (pid < 0) rb_sys_fail(pname);
 	else {
 	    VALUE port = io_alloc(rb_cIO);
Only in .: io.c.orig
diff -ur ../ruby-1.8.7-p249.org/process.c ./process.c
--- ../ruby-1.8.7-p249.org/process.c	2008-06-29 18:34:43.000000000 +0900
+++ ./process.c	2010-01-27 20:59:35.000000000 +0900
@@ -1330,7 +1330,14 @@
     fflush(stderr);
 #endif
 
-    switch (pid = fork()) {
+#if defined(__NetBSD__) || defined(__APPLE__)
+    before_exec();
+#endif
+    pid = fork();
+#if defined(__NetBSD__) || defined(__APPLE__)
+    after_exec();
+#endif
+    switch (pid) {
       case 0:
 #ifdef linux
 	after_exec();
@@ -1570,6 +1577,9 @@
 
     chfunc = signal(SIGCHLD, SIG_DFL);
   retry:
+#if defined(__NetBSD__) || defined(__APPLE__)
+    before_exec();
+#endif
     pid = fork();
     if (pid == 0) {
 	/* child process */
@@ -1577,6 +1587,9 @@
 	rb_protect(proc_exec_args, (VALUE)&earg, NULL);
 	_exit(127);
     }
+#if defined(__NetBSD__) || defined(__APPLE__)
+    after_exec();
+#endif
     if (pid < 0) {
 	if (errno == EAGAIN) {
 	    rb_thread_sleep(1);
Only in .: process.c.orig
