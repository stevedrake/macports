Index: src/basemath/base1.c
===================================================================
RCS file: /home/cvs/pari/src/basemath/base1.c,v
retrieving revision 1.248
retrieving revision 1.248.2.1
diff -d -u -r1.248 -r1.248.2.1
--- src/basemath/base1.c	8 Apr 2006 12:11:16 -0000	1.248
+++ src/basemath/base1.c	16 Nov 2006 09:31:52 -0000	1.248.2.1
@@ -1169,7 +1169,7 @@
 {
   GEN nf = cgetg(10,t_VEC);
   GEN x = T->x;
-  GEN invbas, Tr, D, TI, A, dA, MDI, mat = cgetg(8,t_VEC);
+  GEN absdK, invbas, Tr, D, TI, A, dA, MDI, mat = cgetg(8,t_VEC);
   nffp_t F;
   get_nf_fp_compo(T, &F, ro, prec);
 
@@ -1190,10 +1190,11 @@
   if (DEBUGLEVEL) msgtimer("mult. table");
 
   Tr = get_Tr(gel(nf,9), x, F.basden);
-  TI = ZM_inv(Tr, T->dK); /* dK T^-1 */
+  absdK = T->dK; if (signe(absdK) < 0) absdK = negi(absdK);
+  TI = ZM_inv(Tr, absdK); /* dK T^-1 */
   A = Q_primitive_part(TI, &dA);
   gel(mat,6) = A; /* primitive part of codifferent, dA its denominator */
-  dA = dA? diviiexact(T->dK, dA): T->dK;
+  dA = dA? diviiexact(absdK, dA): absdK;
   A = hnfmodid(A, dA);
   MDI = ideal_two_elt(nf, A);
   gel(MDI,2) = eltmul_get_table(nf, gel(MDI,2));
Index: src/basemath/base3.c
===================================================================
RCS file: /home/cvs/pari/src/basemath/base3.c,v
retrieving revision 1.194
retrieving revision 1.194.2.1
diff -d -u -r1.194 -r1.194.2.1
--- src/basemath/base3.c	11 Apr 2006 17:28:55 -0000	1.194
+++ src/basemath/base3.c	11 Dec 2006 14:29:52 -0000	1.194.2.1
@@ -631,7 +631,7 @@
       return gcopy(x);
     default: z=cgetg(3,t_POLMOD);
       gel(z,1) = gcopy(gel(nf,1));
-      gel(z,2) = gmul(x,pol_1[varn(nf[1])]); return z;
+      gel(z,2) = gtopoly(x, varn(nf[1])); return z;
   }
 }
 
Index: src/basemath/ifactor1.c
===================================================================
RCS file: /home/cvs/pari/src/basemath/ifactor1.c,v
retrieving revision 1.104.2.2
retrieving revision 1.104.2.3
diff -d -u -r1.104.2.2 -r1.104.2.3
--- src/basemath/ifactor1.c	4 Oct 2006 13:54:31 -0000	1.104.2.2
+++ src/basemath/ifactor1.c	11 Dec 2006 14:06:45 -0000	1.104.2.3
@@ -2432,7 +2432,7 @@
 int
 is_357_power(GEN x, GEN *pt, ulong *mask)
 {
-  long lx = lgefint(x), exponent, resbyte;
+  long lx = lgefint(x), resbyte;
   ulong residue;
   pari_sp av;
   GEN y;
@@ -2468,32 +2468,28 @@
   if (*mask & 5) check_res( 43UL,18);
   if (*mask & 6) check_res( 71UL,21);
 
-  /* priority to higher powers: if we have a 21st, it is easier to rediscover
-   * that its 7th root is a cube than that its cube root is a 7th power */
-  if ( (resbyte = *mask & 4) )
-    exponent = 7;
-  else if ( (resbyte = *mask & 2) )
-    exponent = 5;
-  else
-    { resbyte = 1; exponent = 3; }
-
   av = avma;
-  y = mpround( sqrtnr(itor(x, 3 + (lx-2) / exponent), exponent) );
-  if (!equalii(powiu(y, exponent), x))
+  while (*mask)
   {
-    if (DEBUGLEVEL >= 5)
+    long e, b;
+    /* priority to higher powers: if we have a 21st, it is easier to rediscover
+     * that its 7th root is a cube than that its cube root is a 7th power */
+         if (*mask & 4) { b = 4; e = 7; }
+    else if (*mask & 2) { b = 2; e = 5; }
+    else                { b = 1; e = 3; }
+    y = mpround( sqrtnr(itor(x, 3 + (lx-2)/e), e) );
+    if (equalii(powiu(y,e), x))
     {
-      if (exponent == 3)
-	fprintferr("\tBut it nevertheless wasn't a cube.\n");
-      else
-	fprintferr("\tBut it nevertheless wasn't a %ldth power.\n", exponent);
+      if (!pt) { avma = av; return e; }
+      avma = (pari_sp)y; *pt = gerepileuptoint(av, y);
+      return e;
     }
-    *mask &= ~resbyte; /* turn the bit off */
-    avma = av; return 0;
+    if (DEBUGLEVEL >= 5)
+      fprintferr("\tBut it nevertheless wasn't a %ld%s power.\n", e,eng_ord(e));
+    *mask &= ~b; /* turn the bit off */
+    avma = av;
   }
-  if (!pt) { avma = av; return exponent; }
-  avma = (pari_sp)y; *pt = gerepileuptoint(av, y);
-  return exponent;
+  return 0;
 }
 
 /* p not necessarily prime */
Index: src/basemath/polarit1.c
===================================================================
RCS file: /home/cvs/pari/src/basemath/polarit1.c,v
retrieving revision 1.268.2.1
retrieving revision 1.268.2.2
diff -d -u -r1.268.2.1 -r1.268.2.2
--- src/basemath/polarit1.c	3 Aug 2006 17:21:21 -0000	1.268.2.1
+++ src/basemath/polarit1.c	11 Dec 2006 15:22:37 -0000	1.268.2.2
@@ -2487,23 +2487,26 @@
     /* u is square-free (product of irreducibles of multiplicity e) */
     nb0 = nbfact; N = degpol(u);
     t[nbfact] = FqX_normalize(u, T,p);
-    if (N == 1) nbfact++;
-    else
-    {
+    if (N) {
+      nb0 = nbfact;
+      t[nbfact] = FqX_normalize(u, T,p);
+      if (N == 1) nbfact++;
+      else
+      {
 #if 0
-      nbfact += FqX_split_Berlekamp(t+nbfact, q, T, p);
+        nbfact += FqX_split_Berlekamp(t+nbfact, q, T, p);
 #else
-      GEN P = FqX_split_Trager(t[nbfact], T, p);
-      if (P) {
-        for (j = 1; j < lg(P); j++) t[nbfact++] = gel(P,j);
-      } else {
-        if (DEBUGLEVEL) pari_warn(warner, "FqX_split_Trager failed!");
-        nbfact += FqX_sqf_split(t+nbfact, q, T, p);
-      }
+        GEN P = FqX_split_Trager(t[nbfact], T, p);
+        if (P) {
+          for (j = 1; j < lg(P); j++) t[nbfact++] = gel(P,j);
+        } else {
+          if (DEBUGLEVEL) pari_warn(warner, "FqX_split_Trager failed!");
+          nbfact += FqX_sqf_split(t+nbfact, q, T, p);
+        }
 #endif
+      }
+      for (j = nb0; j < nbfact; j++) E[j] = e;
     }
-    for (j = nb0; j < nbfact; j++) E[j] = e;
-
     if (!degpol(f2)) break;
     f = f2; df1 = df2; e += pk;
   }
Index: src/basemath/polarit3.c
===================================================================
RCS file: /home/cvs/pari/src/basemath/polarit3.c,v
retrieving revision 1.325.2.1
retrieving revision 1.325.2.2
diff -d -u -r1.325.2.1 -r1.325.2.2
--- src/basemath/polarit3.c	24 Aug 2006 21:41:42 -0000	1.325.2.1
+++ src/basemath/polarit3.c	11 Dec 2006 14:27:42 -0000	1.325.2.2
@@ -3320,13 +3320,13 @@
     bound = ZY_ZXY_ResBound(A, B, dB);
     if (bound > 50000)
     {
-      long prec = MEDDEFAULTPREC;
+      long eA = gexpo(A), eB = gexpo(B), prec = nbits2prec(max(eA,eB));
       for(;; prec = (prec-1)<<1)
       {
         GEN run = real_1(prec);
         GEN R = subres(gmul(A, run), gmul(B, run));
         bound = gexpo(R) + 1;
-        if (!gcmp0(R) || bound <= 0) break;
+        if (!gcmp0(R)) break;
       }
       if (dB) bound -= (long)(dbllog2(dB)*degA);
     }
Index: src/basemath/trans1.c
===================================================================
RCS file: /home/cvs/pari/src/basemath/trans1.c,v
retrieving revision 1.211.2.1
retrieving revision 1.211.2.3
diff -d -u -r1.211.2.1 -r1.211.2.3
--- src/basemath/trans1.c	30 Sep 2006 11:05:52 -0000	1.211.2.1
+++ src/basemath/trans1.c	11 Dec 2006 14:24:41 -0000	1.211.2.3
@@ -1201,7 +1201,7 @@
     l2 += m>>TWOPOTBITS_IN_LONG;
   } else { /* rare ! */
     b = -1 - log((double)(ulong)x[2]) + (BITS_IN_LONG-1-ex)*LOG2; /*-1-log(x)*/
-    n = (long)(1 + beta/b);
+    n = (long)(1.1 + beta/b);
     m = 0;
   }
   unr=real_1(l2);
@@ -1211,15 +1211,14 @@
 
   s = 0; l1 = 3; av2 = avma;
   for (i=n; i>=2; i--)
-  {
+  { /* compute X^(n-1)/n! + ... + X/2 + 1 */
     setlg(X,l1); p3 = divrs(X,i);
     s -= expo(p3); p1 = mulrr(p3,p2); setlg(p1,l1);
     l1 += s>>TWOPOTBITS_IN_LONG; if (l1>l2) l1=l2;
     s &= (BITS_IN_LONG-1);
     setlg(unr,l1); p1 = addrr_sign(unr,1, p1,1);
-    setlg(p2,l1); affrr(p1,p2); avma = av2;
+    setlg(p2,l1); affrr(p1,p2); avma = av2; /* p2 <- 1 + (X/i)*p2 */
   }
-  setlg(p2,l2);
   setlg(X,l2); p2 = mulrr(X,p2);
 
   for (i=1; i<=m; i++)
@@ -1588,8 +1587,8 @@
   tmplog2 = newbloc(prec);
   *tmplog2 = evaltyp(t_REAL) | evallg(prec);
   av = avma;
-  n = bit_accuracy(prec) >> 1;
   l = prec+1;
+  n = bit_accuracy(l) >> 1;
   y = divrr(Pi2n(-1, l), agm1r_abs( real2n(2 - n, l) ));
   affrr(divrs(y,n), tmplog2);
   if (glog2) gunclone(glog2);
Index: src/basemath/trans2.c
===================================================================
RCS file: /home/cvs/pari/src/basemath/trans2.c,v
retrieving revision 1.123.2.1
retrieving revision 1.123.2.2
diff -d -u -r1.123.2.1 -r1.123.2.2
--- src/basemath/trans2.c	3 Aug 2006 17:13:36 -0000	1.123.2.1
+++ src/basemath/trans2.c	11 Dec 2006 14:24:41 -0000	1.123.2.2
@@ -409,12 +409,14 @@
 mpsh(GEN x)
 {
   pari_sp av;
-  GEN z;
+  long ex = expo(x), lx;
+  GEN z, res;
 
-  if (!signe(x)) return real_0_bit(expo(x));
-  av = avma;
+  if (!signe(x)) return real_0_bit(ex);
+  lx = lg(x); res = cgetr(lx); av = avma;
+  if (ex < 1 - BITS_IN_LONG) x = rtor(x, lx + nbits2nlong(-ex)-1);
   z = mpexp(x); z = addrr(z, divsr(-1,z)); setexpo(z, expo(z)-1);
-  return gerepileuptoleaf(av, z);
+  affrr(z, res); avma = av; return res;
 }
 
 GEN
@@ -447,19 +449,22 @@
 static GEN
 mpth(GEN x)
 {
-  long l, s = signe(x);
+  long lx, s = signe(x);
   GEN y;
 
   if (!s) return real_0_bit(expo(x));
-  l = lg(x);
-  if (absr_cmp(x, stor(bit_accuracy(l), 3)) >= 0) {
-    y = real_1(l);
+  lx = lg(x);
+  if (absr_cmp(x, stor(bit_accuracy(lx), 3)) >= 0) {
+    y = real_1(lx);
   } else {
     pari_sp av = avma;
-    GEN t = exp1r_abs(gmul2n(x,1)); /* exp(|2x|) - 1 */
+    long ex = expo(x);
+    GEN t;
+    if (ex < 1 - BITS_IN_LONG) x = rtor(x, lx + nbits2nlong(-ex)-1);
+    t = exp1r_abs(gmul2n(x,1)); /* exp(|2x|) - 1 */
     y = gerepileuptoleaf(av, divrr(t, addsr(2,t)));
   }
-  if (s < 0) setsigne(y, -signe(y)); /* tanh is odd */
+  if (s < 0) togglesign(y); /* tanh is odd */
   return y;
 }
 
@@ -497,10 +502,15 @@
 static GEN
 mpash(GEN x)
 {
-  pari_sp av = avma;
-  GEN z = logr_abs( addrr_sign(x,1, sqrtr( addrs(mulrr(x,x), 1) ), 1) );
-  if (signe(x) < 0) setsigne(z, -signe(z));
-  return gerepileuptoleaf(av, z);
+  GEN z, res;
+  pari_sp av;
+  long lx = lg(x), ex = expo(x);
+  
+  res = cgetr(lx); av = avma;
+  if (ex < 1 - BITS_IN_LONG) x = rtor(x, lx + nbits2nlong(-ex)-1);
+  z = logr_abs( addrr_sign(x,1, sqrtr( addrs(mulrr(x,x), 1) ), 1) );
+  if (signe(x) < 0) togglesign(z);
+  affrr(z, res); avma = av; return res;
 }
 
 GEN
@@ -623,7 +633,10 @@
 mpath(GEN x)
 {
   pari_sp av = avma;
-  GEN z = logr_abs( addrs(divsr(2,subsr(1,x)), -1) );
+  long ex = expo(x);
+  GEN z;
+  if (ex < 1 - BITS_IN_LONG) x = rtor(x, lg(x) + nbits2nlong(-ex)-1);
+  z = logr_abs( addrs(divsr(2,subsr(1,x)), -1) );
   setexpo(z, expo(z)-1); return gerepileuptoleaf(av, z);
 }
 
Index: src/headers/parigen.h
===================================================================
RCS file: /home/cvs/pari/src/headers/parigen.h,v
retrieving revision 1.27
retrieving revision 1.27.2.1
diff -d -u -r1.27 -r1.27.2.1
--- src/headers/parigen.h	19 Apr 2006 16:18:26 -0000	1.27
+++ src/headers/parigen.h	11 Dec 2006 14:24:41 -0000	1.27.2.1
@@ -105,6 +105,7 @@
 #define signe(x)      ((((long*)(x))[1]) >> SIGNSHIFT)
 #define setsigne(x,s) (((ulong*)(x))[1]=\
                         (((ulong*)(x))[1]&(~SIGNBITS)) | (ulong)evalsigne(s))
+#define togglesign(x) (void)((((GEN)(x))[1] & SIGNBITS) && (((GEN)(x))[1] ^= HIGHBIT))
 
 #define lgeflist(x)      (((long*)(x))[1])
 #define setlgeflist(x,l) (((ulong*)(x))[1]=(ulong)(l))
Index: src/kernel/gmp/mp.c
===================================================================
RCS file: /home/cvs/pari/src/kernel/gmp/mp.c,v
retrieving revision 1.87.2.1
retrieving revision 1.87.2.2
diff -d -u -r1.87.2.1 -r1.87.2.2
--- src/kernel/gmp/mp.c	12 Sep 2006 13:52:04 -0000	1.87.2.1
+++ src/kernel/gmp/mp.c	22 Nov 2006 21:20:28 -0000	1.87.2.2
@@ -126,7 +126,10 @@
 
 /* we had a = setloop(?), then some incloops. Reset a to b */
 GEN
-resetloop(GEN a, GEN b) { affii(b, a); return a; }
+resetloop(GEN a, GEN b) {
+  a[0] = evaltyp(t_INT) | evallg(lgefint(b));
+  affii(b, a); return a;
+}
 
 /* assume a > 0, initialized by setloop. Do a++ */
 static GEN
Index: src/language/members.c
===================================================================
RCS file: /home/cvs/pari/src/language/members.c,v
retrieving revision 1.24
retrieving revision 1.24.2.1
diff -d -u -r1.24 -r1.24.2.1
--- src/language/members.c	15 Mar 2006 09:26:40 -0000	1.24
+++ src/language/members.c	16 Nov 2006 16:18:31 -0000	1.24.2.1
@@ -206,9 +206,10 @@
 GEN
 member_codiff(GEN x) /* codifferent */
 {
-  long t; GEN nf = get_nf(x,&t), y = nfmats(nf);
+  long t; GEN H, nf = get_nf(x,&t), y = nfmats(nf);
   if (!y) member_err("codiff");
-  return gdiv(gel(y,6), absi(gel(nf,3)));
+  H = hnf(gel(y,6));
+  return gdiv(H, gcoeff(H,1,1));
 }
 
 GEN
