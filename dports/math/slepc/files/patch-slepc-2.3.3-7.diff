Index: config/configure.py
diff -u config/configure.py:1.23 config/configure.py:1.23.2.1
--- config/configure.py:1.23	Thu May 31 17:11:23 2007
+++ config/configure.py	Mon Oct  1 12:39:43 2007
@@ -163,6 +163,13 @@
 log.Write('Configure Options: '+str.join(' ',sys.argv))
 log.Write('Working directory: '+os.getcwd())
 log.Write('Python version:\n' + sys.version)
+log.Write('make: ' + petscconf.MAKE)
+log.Write('PETSc source directory: ' + petscdir)
+log.Write('PETSc install directory: ' + petscconf.INSTALL_DIR)
+log.Write('PETSc version: ' + petscconf.VERSION)
+log.Write('PETSc architecture: ' + petscconf.ARCH)
+log.Write('SLEPc source directory: ' + slepcdir)
+log.Write('SLEPc install directory: ' + prefixdir)
 log.Write('='*80)
 
 # Check if PETSc is working
Index: config/lapack.py
diff -u config/lapack.py:1.12 config/lapack.py:1.12.2.2
--- config/lapack.py:1.12	Thu May 31 17:11:23 2007
+++ config/lapack.py	Tue Dec 18 18:35:41 2007
@@ -52,23 +52,24 @@
       conf.write(' -DSLEPC_MISSING_LAPACK_' + i.upper())
 
 
+  functions = ['stevr','bdsdc']
   if petscconf.PRECISION == 'single':
-    functions = ['slamch','sstevr','sbdsdc']
+    prefix = 's'
   else:
-    functions = ['dlamch','dstevr','dbdsdc']
+    prefix = 'd'
 
   for i in functions:
     f =  '#if defined(PETSC_HAVE_FORTRAN_UNDERSCORE) || defined(PETSC_BLASLAPACK_UNDERSCORE)\n'
-    f += i + '_\n'
+    f += prefix + i + '_\n'
     f += '#elif defined(PETSC_HAVE_FORTRAN_CAPS)\n'
-    f += i.upper() + '\n'
+    f += prefix.upper() + i.upper() + '\n'
     f += '#else\n'
-    f += i + '\n'
+    f += prefix + i + '\n'
     f += '#endif\n'
    
     log.Write('=== Checking LAPACK '+i+' function...')
     if not check.Link([f],[],[]):
-      missing.append(i)
+      missing.append(prefix + i)
       conf.write(' -DSLEPC_MISSING_LAPACK_' + i.upper())
   
   conf.write('\n')
Index: include/slepc.h
diff -u include/slepc.h:1.11 include/slepc.h:1.11.4.1
--- include/slepc.h:1.11	Thu May 31 17:04:53 2007
+++ include/slepc.h	Thu Jul  5 13:03:48 2007
@@ -47,6 +47,8 @@
 EXTERN PetscErrorCode SlepcMatConvertSeqDense(Mat,Mat*);
 EXTERN PetscErrorCode SlepcCheckOrthogonality(Vec*,PetscInt,Vec *,PetscInt,Mat,PetscScalar*);
  
+extern PetscTruth SlepcInitializeCalled;
+
 PETSC_EXTERN_CXX_END
 #endif
 
Index: include/slepcblaslapack.h
diff -u include/slepcblaslapack.h:1.31 include/slepcblaslapack.h:1.31.4.1
--- include/slepcblaslapack.h:1.31	Thu May 31 17:04:53 2007
+++ include/slepcblaslapack.h	Mon Dec 17 18:55:35 2007
@@ -97,13 +97,11 @@
 #define LAPACKormlq_ SLEPC_BLASLAPACK(unmlq,UNMLQ)
 #endif
 
-#define LAPACKlamch_ SLEPC_BLASLAPACKREAL(lamch,LAMCH)
 #define LAPACKstevr_ SLEPC_BLASLAPACKREAL(stevr,STEVR)
 #define LAPACKbdsdc_ SLEPC_BLASLAPACKREAL(bdsdc,BDSDC)
 
 EXTERN_C_BEGIN
 
-EXTERN PetscReal LAPACKlamch_(const char*,PetscBLASInt);
 EXTERN PetscReal LAPACKlanhs_(const char*,PetscBLASInt*,PetscScalar*,PetscBLASInt*,PetscReal*,PetscBLASInt);
 EXTERN PetscReal LAPACKlange_(const char*,PetscBLASInt*,PetscBLASInt*,PetscScalar*,PetscBLASInt*,PetscReal*,PetscBLASInt);
 EXTERN void      LAPACKlaev2_(PetscScalar*,PetscScalar*,PetscScalar*,PetscReal*,PetscReal*,PetscReal*,PetscScalar*);
Index: include/slepcsvd.h
diff -u include/slepcsvd.h:1.26 include/slepcsvd.h:1.26.2.2
--- include/slepcsvd.h:1.26	Fri Jun  1 16:15:48 2007
+++ include/slepcsvd.h	Thu Jul  5 18:21:10 2007
@@ -139,4 +139,5 @@
 #endif
 EXTERN PetscErrorCode SVDRegisterDestroy(void);
 
+PETSC_EXTERN_CXX_END
 #endif
Index: include/slepcversion.h
diff -u include/slepcversion.h:1.13 include/slepcversion.h:1.13.2.7
--- include/slepcversion.h:1.13	Fri Jun  1 18:25:57 2007
+++ include/slepcversion.h	Mon Mar  3 17:48:21 2008
@@ -19,9 +19,9 @@
 #define SLEPC_VERSION_MAJOR      2
 #define SLEPC_VERSION_MINOR      3
 #define SLEPC_VERSION_SUBMINOR   3
-#define SLEPC_VERSION_PATCH      0
+#define SLEPC_VERSION_PATCH      7
 #define SLEPC_VERSION_DATE       "June 1, 2007"
-#define SLEPC_VERSION_PATCH_DATE "June 1, 2007"
+#define SLEPC_VERSION_PATCH_DATE "March 3, 2008"
 #define SLEPC_AUTHOR_INFO        "        The SLEPc Team\n\
    slepc-maint@grycap.upv.es\n\
  http://www.grycap.upv.es/slepc\n"
Index: include/finclude/slepceps.h
diff -u include/finclude/slepceps.h:1.7 include/finclude/slepceps.h:1.7.4.1
--- include/finclude/slepceps.h:1.7	Thu May 31 17:04:53 2007
+++ include/finclude/slepceps.h	Thu Jan 31 16:21:32 2008
@@ -21,12 +21,13 @@
 #define EPSSUBSPACE  'subspace'
 #define EPSARNOLDI   'arnoldi'
 #define EPSLANCZOS   'lanczos'
+#define EPSKRYLOVSCHUR 'krylovschur'
 #define EPSLAPACK    'lapack'
 #define EPSARPACK    'arpack'
 #define EPSBLZPACK   'blzpack'
-#define EPSPLANSO    'planso'
 #define EPSTRLAN     'trlan'
-#define EPSLOBPCG    'lobpcg'
+#define EPSBLOPEX    'blopex'
+#define EPSPRIMME    'primme'
 
 !  Convergence flags.
 !  They sould match the flags in $SLEPC_DIR/include/slepceps.h
@@ -66,20 +67,6 @@
       parameter (EPS_SMALLEST_REAL          =  3)
       parameter (EPS_LARGEST_IMAGINARY      =  4)
       parameter (EPS_SMALLEST_IMAGINARY     =  5)
-
-      integer EPS_MGS_ORTH
-      integer EPS_CGS_ORTH
-      
-      parameter (EPS_MGS_ORTH               =  0)
-      parameter (EPS_CGS_ORTH               =  1)
-
-      integer EPS_ORTH_REFINE_NEVER
-      integer EPS_ORTH_REFINE_IFNEEDED
-      integer EPS_ORTH_REFINE_ALWAYS 
-
-      parameter (EPS_ORTH_REFINE_NEVER      =  0)  
-      parameter (EPS_ORTH_REFINE_IFNEEDED   =  1)  
-      parameter (EPS_ORTH_REFINE_ALWAYS     =  2)  
        
       integer EPSPOWER_SHIFT_CONSTANT
       integer EPSPOWER_SHIFT_RAYLEIGH
@@ -94,17 +81,65 @@
 
       parameter (EPS_ONE_SIDE               =  0)
       parameter (EPS_TWO_SIDE               =  1)
+      
+      integer EPS_RITZ
+      integer EPS_HARMONIC
+      integer EPS_REFINED
+      integer EPS_REFINED_HARMONIC
+
+      parameter (EPS_RITZ                   =  1)
+      parameter (EPS_HARMONIC               =  2)
+      parameter (EPS_REFINED                =  3)
+      parameter (EPS_REFINED_HARMONIC       =  4)
 
-      integer EPSLANCZOS_REORTHOG_NONE
+      integer EPSLANCZOS_REORTHOG_LOCAL
       integer EPSLANCZOS_REORTHOG_FULL
       integer EPSLANCZOS_REORTHOG_SELECTIVE
       integer EPSLANCZOS_REORTHOG_PERIODIC
       integer EPSLANCZOS_REORTHOG_PARTIAL
 
-      parameter (EPSLANCZOS_REORTHOG_NONE      =  0)
+      parameter (EPSLANCZOS_REORTHOG_LOCAL      =  0)
       parameter (EPSLANCZOS_REORTHOG_FULL      =  1)
       parameter (EPSLANCZOS_REORTHOG_SELECTIVE =  2)
       parameter (EPSLANCZOS_REORTHOG_PERIODIC  =  3)
       parameter (EPSLANCZOS_REORTHOG_PARTIAL   =  4)
 
+      integer EPSPRIMME_DYNAMIC
+      integer EPSPRIMME_DEFAULT_MIN_TIME
+      integer EPSPRIMME_DEFAULT_MIN_MATVECS
+      integer EPSPRIMME_ARNOLDI
+      integer EPSPRIMME_GD
+      integer EPSPRIMME_GD_PLUSK
+      integer EPSPRIMME_GD_OLSEN_PLUSK
+      integer EPSPRIMME_JD_OLSEN_PLUSK
+      integer EPSPRIMME_RQI
+      integer EPSPRIMME_JDQR
+      integer EPSPRIMME_JDQMR
+      integer EPSPRIMME_JDQMR_ETOL
+      integer EPSPRIMME_SUBSPACE_ITERATION
+      integer EPSPRIMME_LOBPCG_ORTHOBASIS
+      integer EPSPRIMME_LOBPCG_ORTHOBASIS_WINDOW
+
+      parameter (EPSPRIMME_DYNAMIC                  =  0)
+      parameter (EPSPRIMME_DEFAULT_MIN_TIME         =  1)
+      parameter (EPSPRIMME_DEFAULT_MIN_MATVECS      =  2)
+      parameter (EPSPRIMME_ARNOLDI                  =  3)
+      parameter (EPSPRIMME_GD                       =  4)
+      parameter (EPSPRIMME_GD_PLUSK                 =  5)
+      parameter (EPSPRIMME_GD_OLSEN_PLUSK           =  7)
+      parameter (EPSPRIMME_JD_OLSEN_PLUSK           =  8)
+      parameter (EPSPRIMME_RQI                      =  9)
+      parameter (EPSPRIMME_JDQR                     = 10)
+      parameter (EPSPRIMME_JDQMR                    = 11)
+      parameter (EPSPRIMME_JDQMR_ETOL               = 12)
+      parameter (EPSPRIMME_SUBSPACE_ITERATION       = 13)
+      parameter (EPSPRIMME_LOBPCG_ORTHOBASIS        = 14)
+      parameter (EPSPRIMME_LOBPCG_ORTHOBASIS_WINDOW = 15)
+
+      integer EPSPRIMME_NONE
+      integer EPSPRIMME_DIAGONAL
+
+      parameter (EPSPRIMME_NONE               =  0)
+      parameter (EPSPRIMME_DIAGONAL           =  1)
+
 #endif
Index: include/finclude/slepcip.h
diff -u /dev/null include/finclude/slepcip.h:1.1
--- /dev/null	Mon Mar  3 17:49:38 2008
+++ include/finclude/slepcip.h	Thu Jan 31 15:48:33 2008
@@ -0,0 +1,38 @@
+!
+!  Include file for Fortran use of the IP object in SLEPc
+!
+!
+!  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!     SLEPc - Scalable Library for Eigenvalue Problem Computations
+!     Copyright (c) 2002-2007, Universidad Politecnica de Valencia, Spain
+!
+!     This file is part of SLEPc. See the README file for conditions of use
+!     and additional information.
+!  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!
+#if !defined(__SLEPCIP_H)
+#define __SLEPCIP_H
+
+#define IP                PetscFortranAddr
+
+      integer IP_MGS_ORTH
+      integer IP_CGS_ORTH
+      
+      parameter (IP_MGS_ORTH               =  0)
+      parameter (IP_CGS_ORTH               =  1)
+
+      integer IP_ORTH_REFINE_NEVER
+      integer IP_ORTH_REFINE_IFNEEDED
+      integer IP_ORTH_REFINE_ALWAYS 
+
+      parameter (IP_ORTH_REFINE_NEVER      =  0)  
+      parameter (IP_ORTH_REFINE_IFNEEDED   =  1)  
+      parameter (IP_ORTH_REFINE_ALWAYS     =  2)  
+
+      integer IP_MGS_ORTH
+      integer IP_CGS_ORTH
+
+      parameter (IP_MGS_ORTH               =  0)
+      parameter (IP_CGS_ORTH               =  1)
+
+#endif
Index: include/finclude/slepcst.h
diff -u include/finclude/slepcst.h:1.5 include/finclude/slepcst.h:1.5.4.1
--- include/finclude/slepcst.h:1.5	Thu May 31 17:04:53 2007
+++ include/finclude/slepcst.h	Thu Jan 31 16:24:04 2008
@@ -29,14 +29,4 @@
       parameter (STMATMODE_INPLACE       =  1)
       parameter (STMATMODE_SHELL         =  2)
 
-      integer STINNER_HERMITIAN
-      integer STINNER_SYMMETRIC
-      integer STINNER_B_HERMITIAN
-      integer STINNER_B_SYMMETRIC
-
-      parameter (STINNER_HERMITIAN       =  0)
-      parameter (STINNER_SYMMETRIC       =  1)
-      parameter (STINNER_B_HERMITIAN     =  2)
-      parameter (STINNER_B_SYMMETRIC     =  3)
-
 #endif
Index: include/finclude/slepcsvd.h
diff -u /dev/null include/finclude/slepcsvd.h:1.2
--- /dev/null	Mon Mar  3 17:49:38 2008
+++ include/finclude/slepcsvd.h	Thu Jan 31 15:48:33 2008
@@ -0,0 +1,51 @@
+!
+!  Include file for Fortran use of the SVD object in SLEPc
+!
+!
+!  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!     SLEPc - Scalable Library for Eigenvalue Problem Computations
+!     Copyright (c) 2002-2007, Universidad Politecnica de Valencia, Spain
+!
+!     This file is part of SLEPc. See the README file for conditions of use
+!     and additional information.
+!  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!
+#if !defined(__SLEPCSVD_H)
+#define __SLEPCSVD_H
+
+#define SVD                PetscFortranAddr
+#define SVDType            character*(80)
+#define SVDConvergedReason integer
+
+#define SVDCROSS     'cross'
+#define SVDCYCLIC    'cyclic'
+#define SVDLAPACK    'lapack'
+#define SVDLANCZOS   'lanczos'
+#define SVDTRLANCZOS 'trlanczos'
+
+!  Convergence flags.
+!  They sould match the flags in $SLEPC_DIR/include/slepcsvd.h
+
+      integer SVD_CONVERGED_TOL        
+      integer SVD_DIVERGED_ITS
+      integer SVD_DIVERGED_BREAKDOWN
+      integer SVD_CONVERGED_ITERATING
+
+      parameter (SVD_CONVERGED_TOL          =  2)
+      parameter (SVD_DIVERGED_ITS           = -3)
+      parameter (SVD_DIVERGED_BREAKDOWN     = -4)
+      parameter (SVD_CONVERGED_ITERATING    =  0)
+
+      integer SVD_TRANSPOSE_EXPLICIT
+      integer SVD_TRANSPOSE_IMPLICIT 
+
+      parameter (SVD_TRANSPOSE_EXPLICIT     =  0)
+      parameter (SVD_TRANSPOSE_IMPLICIT     =  1)
+      
+      integer SVD_LARGEST
+      integer SVD_SMALLEST
+
+      parameter (SVD_LARGEST                =  0)
+      parameter (SVD_SMALLEST               =  1)
+
+#endif
Index: src/eps/impls/primme/primmes.c
diff -u src/eps/impls/primme/primmes.c:1.20 src/eps/impls/primme/primmes.c:1.20.2.1
--- src/eps/impls/primme/primmes.c:1.20	Thu May 31 20:03:41 2007
+++ src/eps/impls/primme/primmes.c	Mon Mar  3 17:48:21 2008
@@ -67,7 +67,8 @@
 static void applyPreconditioner_PRIMME(void *in, void *out, int *blockSize, struct primme_params *primme);
 
 static void par_GlobalSumDouble(void *sendBuf, void *recvBuf, int *count, primme_params *primme) {
-  MPI_Allreduce((double*)sendBuf, (double*)recvBuf, *count, MPI_DOUBLE, MPI_SUM, ((EPS)(primme->commInfo))->comm);
+  PetscErrorCode ierr;
+  ierr = MPI_Allreduce((double*)sendBuf, (double*)recvBuf, *count, MPI_DOUBLE, MPI_SUM, ((EPS)(primme->commInfo))->comm);CHKERRABORT(((EPS)(primme->commInfo))->comm,ierr);
 }
 
 #undef __FUNCT__  
@@ -82,8 +83,8 @@
 
   PetscFunctionBegin;
 
-  MPI_Comm_size(eps->comm,&numProcs);
-  MPI_Comm_rank(eps->comm,&procID);
+  ierr = MPI_Comm_size(eps->comm,&numProcs);CHKERRQ(ierr);
+  ierr = MPI_Comm_rank(eps->comm,&procID);CHKERRQ(ierr);
   
   /* Check some constraints and set some default values */ 
   ierr = VecGetSize(eps->vec_initial,&N);CHKERRQ(ierr);
@@ -331,7 +332,7 @@
   if (flg) {ierr = EPSPRIMMESetBlockSize(eps,op);CHKERRQ(ierr);}
   op = 0;
   ierr = PetscOptionsEList("-eps_primme_method","set method for solving the eigenproblem",
-                           "EPSPRIMMESetMethod",methodList,15,methodList[0],&op,&flg); CHKERRQ(ierr);
+                           "EPSPRIMMESetMethod",methodList,15,methodList[1],&op,&flg); CHKERRQ(ierr);
   if (flg) {ierr = EPSPRIMMESetMethod(eps, methodN[op]);CHKERRQ(ierr);}
   ierr = PetscOptionsEList("-eps_primme_precond","set preconditioner type",
                            "EPSPRIMMESetPrecond",precondList,2,precondList[0],&op,&flg); CHKERRQ(ierr);
@@ -456,7 +457,7 @@
 
   PetscFunctionBegin;
 
-  if (method == PETSC_DEFAULT) ops->method = DYNAMIC;
+  if (method == PETSC_DEFAULT) ops->method = DEFAULT_MIN_TIME;
   else ops->method = (primme_preset_method)method;
 
   PetscFunctionReturn(0);
@@ -484,7 +485,7 @@
 .  -eps_primme_set_method - Sets the method for the PRIMME library.
 
    Note:
-   If not set, the method defaults to EPSPRIMME_DYNAMIC.
+   If not set, the method defaults to EPSPRIMME_DEFAULT_MIN_TIME.
 
    Level: advanced
 
@@ -690,7 +691,7 @@
   primme_initialize(&primme->primme);
   primme->primme.matrixMatvec = multMatvec_PRIMME;
   primme->primme.globalSumDouble = par_GlobalSumDouble;
-  primme->method = DYNAMIC;
+  primme->method = EPSPRIMME_DEFAULT_MIN_TIME;
   ierr = PetscObjectComposeFunctionDynamic((PetscObject)eps,"EPSPRIMMESetBlockSize_C","EPSPRIMMESetBlockSize_PRIMME",EPSPRIMMESetBlockSize_PRIMME);CHKERRQ(ierr);
   ierr = PetscObjectComposeFunctionDynamic((PetscObject)eps,"EPSPRIMMESetMethod_C","EPSPRIMMESetMethod_PRIMME",EPSPRIMMESetMethod_PRIMME);CHKERRQ(ierr);
   ierr = PetscObjectComposeFunctionDynamic((PetscObject)eps,"EPSPRIMMESetPrecond_C","EPSPRIMMESetPrecond_PRIMME",EPSPRIMMESetPrecond_PRIMME);CHKERRQ(ierr); 
Index: src/eps/interface/basic.c
diff -u src/eps/interface/basic.c:1.31 src/eps/interface/basic.c:1.31.2.1
--- src/eps/interface/basic.c:1.31	Fri Jun  1 15:13:24 2007
+++ src/eps/interface/basic.c	Mon Mar  3 17:48:21 2008
@@ -208,7 +208,7 @@
   PetscValidPointer(outeps,2);
   *outeps = 0;
 
-  PetscHeaderCreate(eps,_p_EPS,struct _EPSOps,EPS_COOKIE,-1,"EPS",comm,EPSDestroy,EPSView);
+  ierr = PetscHeaderCreate(eps,_p_EPS,struct _EPSOps,EPS_COOKIE,-1,"EPS",comm,EPSDestroy,EPSView);CHKERRQ(ierr);
   *outeps = eps;
 
   eps->bops->publish   = EPSPublish_Petsc;
Index: src/eps/interface/dense.c
diff -u src/eps/interface/dense.c:1.44 src/eps/interface/dense.c:1.44.4.1
--- src/eps/interface/dense.c:1.44	Thu May 31 17:05:03 2007
+++ src/eps/interface/dense.c	Tue Dec 18 18:38:06 2007
@@ -651,9 +651,9 @@
 @*/
 PetscErrorCode EPSDenseTridiagonal(int n,PetscScalar *A,int lda,PetscReal *w,PetscScalar *V)
 {
-#if defined(SLEPC_MISSING_LAPACK_DSTEVR)
+#if defined(SLEPC_MISSING_LAPACK_STEVR)
   PetscFunctionBegin;
-  SETERRQ(PETSC_ERR_SUP,"DSTEVR - Lapack routine is unavailable.");
+  SETERRQ(PETSC_ERR_SUP,"STEVR - Lapack routine is unavailable.");
 #else
   PetscErrorCode ierr;
   PetscReal      abstol = 0.0,vl,vu,*D,*E,*work;
Index: src/examples/makefile
diff -u src/examples/makefile:1.25 src/examples/makefile:1.25.4.1
--- src/examples/makefile:1.25	Thu May 31 17:38:15 2007
+++ src/examples/makefile	Mon Mar  3 17:48:21 2008
@@ -99,103 +99,127 @@
 #------------------------------------------------------------------------------------
 
 runex1_1:
-	-@${MPIEXEC} -np 1 ex1 > ex1_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex1 > ex1_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex1_1.out ex1_1.tmp) then true; \
 	   else echo "Possible problem with ex1_1, diffs above"; fi; \
 	   ${RM} -f ex1_1.tmp
 
+testex1: ex1.PETSc
+	@if [ "${PETSC_WITH_BATCH}" != "" ]; then \
+           echo "Running with batch filesystem; to test run src/examples/ex1 with" ; \
+           echo "your systems batch system"; \
+	else \
+           ${MPIEXEC} -np 1 ./ex1 > ex1_1.tmp 2>&1; \
+	   if (${DIFF} output/ex1_1.out ex1_1.tmp > /dev/null 2>&1) then \
+           echo "C/C++ example src/examples/ex1 run successfully with 1 MPI process"; \
+	   else echo "Possible error running C/C++ src/examples/ex1 with 1 MPI process"; \
+           cat ex1_1.tmp; fi; \
+           ${RM} -f ex1_1.tmp; fi
+
 runex1f_1:
-	-@${MPIEXEC} -np 1 ex1f > ex1f_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex1f > ex1f_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex1f_1.out ex1f_1.tmp) then true; \
 	   else echo "Possible problem with ex1f_1, diffs above"; fi; \
 	   ${RM} -f ex1f_1.tmp
 
+testex1f: ex1f.PETSc
+	@if [ "${PETSC_WITH_BATCH}" != "" ]; then \
+	   echo "Running with batch filesystem; to test run src/examples/ex1f with" ; \
+	   echo "your systems batch system"; \
+	else \
+           ${MPIEXEC} -np 1 ./ex1f > ex1f_1.tmp 2>&1; \
+	   if (${DIFF} output/ex1f_1.out ex1f_1.tmp > /dev/null 2>&1) then \
+           echo "Fortran example src/examples/ex1f run successfully with 1 MPI process"; \
+	   else echo "Possible error running Fortran src/examples/ex1f with 1 MPI process"; \
+           cat ex1f_1.tmp; fi; \
+           ${RM} -f ex1f_1.tmp; fi
+
 runex2_1:
-	-@${MPIEXEC} -np 1 ex2 > ex2_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex2 > ex2_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex2_1.out ex2_1.tmp) then true; \
 	   else echo "Possible problem with ex2_1, diffs above"; fi; \
 	   ${RM} -f ex2_1.tmp
 
 runex3_1:
-	-@${MPIEXEC} -np 1 ex3 > ex3_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex3 > ex3_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex3_1.out ex3_1.tmp) then true; \
 	   else echo "Possible problem with ex3_1, diffs above"; fi; \
 	   ${RM} -f ex3_1.tmp
 
 runex4_1:
-	-@${MPIEXEC} -np 1 ex4 -file ${SLEPC_DIR}/src/mat/examples/rdb200.petsc > ex4_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex4 -file ${SLEPC_DIR}/src/mat/examples/rdb200.petsc > ex4_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex4_1.out ex4_1.tmp) then true; \
 	   else echo "Possible problem with ex4_1, diffs above"; fi; \
 	   ${RM} -f ex4_1.tmp
 
 runex5_1:
-	-@${MPIEXEC} -np 1 ex5 -st_shift 1 > ex5_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex5 -st_shift 1 > ex5_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex5_1.out ex5_1.tmp) then true; \
 	   else echo "Possible problem with ex5_1, diffs above"; fi; \
 	   ${RM} -f ex5_1.tmp
 
 runex5_2:
-	-@${MPIEXEC} -np 2 ex5 -st_shift 1 > ex5_2.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 2 ./ex5 -st_shift 1 > ex5_2.tmp 2>&1;	  \
 	   if (${DIFF} output/ex5_1.out ex5_2.tmp) then true; \
 	   else echo "Possible problem with ex5_2, diffs above"; fi; \
 	   ${RM} -f ex5_2.tmp
 
 runex6f_1:
-	-@${MPIEXEC} -np 1 ex6f -st_shift 1 -eps_max_it 1000 -eps_ncv 12 -eps_tol 1e-5 > ex6f_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex6f -st_shift 1 -eps_max_it 1000 -eps_ncv 12 -eps_tol 1e-5 > ex6f_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex6f_1.out ex6f_1.tmp) then true; \
 	   else echo "Possible problem with ex6f_1, diffs above"; fi; \
 	   ${RM} -f ex6f_1.tmp
 
 runex7_1:
-	-@${MPIEXEC} -np 1 ex7 -f1 ${SLEPC_DIR}/src/mat/examples/bfw62a.petsc -f2 ${SLEPC_DIR}/src/mat/examples/bfw62b.petsc > ex7_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex7 -f1 ${SLEPC_DIR}/src/mat/examples/bfw62a.petsc -f2 ${SLEPC_DIR}/src/mat/examples/bfw62b.petsc > ex7_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex7_1.out ex7_1.tmp) then true; \
 	   else echo "Possible problem with ex7_1, diffs above"; fi; \
 	   ${RM} -f ex7_1.tmp
 
 runex8_1:
-	-@${MPIEXEC} -np 1 ex8 > ex8_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex8 > ex8_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex8_1.out ex8_1.tmp) then true; \
 	   else echo "Possible problem with ex8_1, diffs above"; fi; \
 	   ${RM} -f ex8_1.tmp
 
 runex9_1:
-	-@${MPIEXEC} -np 1 ex9 > ex9_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex9 > ex9_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex9_1.out ex9_1.tmp) then true; \
 	   else echo "Possible problem with ex9_1, diffs above"; fi; \
 	   ${RM} -f ex9_1.tmp
 
 runex10_1:
-	-@${MPIEXEC} -np 1 ex10 > ex10_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex10 > ex10_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex10_1.out ex10_1.tmp) then true; \
 	   else echo "Possible problem with ex10_1, diffs above"; fi; \
 	   ${RM} -f ex10_1.tmp
 
 runex11_1:
-	-@${MPIEXEC} -np 1 ex11 > ex11_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex11 > ex11_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex11_1.out ex11_1.tmp) then true; \
 	   else echo "Possible problem with ex11_1, diffs above"; fi; \
 	   ${RM} -f ex11_1.tmp
 
 runex12_1:
-	-@${MPIEXEC} -np 1 ex12 -eps_type power -st_shift 1 -eps_nev 2 > ex12_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex12 -eps_type power -st_shift 1 -eps_nev 2 > ex12_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex12_1.out ex12_1.tmp) then true; \
 	   else echo "Possible problem with ex12_1, diffs above"; fi; \
 	   ${RM} -f ex12_1.tmp
 
 runex13_1:
-	-@${MPIEXEC} -np 1 ex13 > ex13_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex13 > ex13_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex13_1.out ex13_1.tmp) then true; \
 	   else echo "Possible problem with ex13_1, diffs above"; fi; \
 	   ${RM} -f ex13_1.tmp
 
 runex14_1:
-	-@${MPIEXEC} -np 1 ex14 -file ${SLEPC_DIR}/src/mat/examples/rdb200.petsc > ex14_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex14 -file ${SLEPC_DIR}/src/mat/examples/rdb200.petsc > ex14_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex14_1.out ex14_1.tmp) then true; \
 	   else echo "Possible problem with ex14_1, diffs above"; fi; \
 	   ${RM} -f ex14_1.tmp
 
 runex15_1:
-	-@${MPIEXEC} -np 1 ex15 > ex15_1.tmp 2>&1;	  \
+	-@${MPIEXEC} -np 1 ./ex15 > ex15_1.tmp 2>&1;	  \
 	   if (${DIFF} output/ex15_1.out ex15_1.tmp) then true; \
 	   else echo "Possible problem with ex15_1, diffs above"; fi; \
 	   ${RM} -f ex15_1.tmp
Index: src/ip/ipbasic.c
diff -u src/ip/ipbasic.c:1.9 src/ip/ipbasic.c:1.9.4.1
--- src/ip/ipbasic.c:1.9	Thu May 31 17:05:03 2007
+++ src/ip/ipbasic.c	Mon Mar  3 17:48:21 2008
@@ -101,7 +101,7 @@
 
   PetscFunctionBegin;
   PetscValidPointer(newip,2);
-  PetscHeaderCreate(ip,_p_IP,struct _IPOps,IP_COOKIE,-1,"IP",comm,IPDestroy,IPView);
+  ierr = PetscHeaderCreate(ip,_p_IP,struct _IPOps,IP_COOKIE,-1,"IP",comm,IPDestroy,IPView);CHKERRQ(ierr);
   *newip            = ip;
   ip->orthog_type   = IP_CGS_ORTH;
   ip->orthog_ref    = IP_ORTH_REFINE_IFNEEDED;
Index: src/ip/ipdot.c
diff -u src/ip/ipdot.c:1.6 src/ip/ipdot.c:1.6.4.1
--- src/ip/ipdot.c:1.6	Thu May 31 17:59:26 2007
+++ src/ip/ipdot.c	Fri Nov 30 18:52:04 2007
@@ -48,19 +48,21 @@
   PetscValidHeaderSpecific(x,VEC_COOKIE,2);
   PetscValidPointer(norm,3);
   
-  ierr = IPInnerProduct(ip,x,x,&p);CHKERRQ(ierr);
-
-  if (PetscAbsScalar(p)<PETSC_MACHINE_EPSILON)
-    PetscInfo(ip,"Zero norm, either the vector is zero or a semi-inner product is being used\n");
-
+  if (!ip->matrix && ip->bilinear_form == IPINNER_HERMITIAN) {
+    ierr = VecNorm(x,NORM_2,norm);CHKERRQ(ierr);
+  } else {
+    ierr = IPInnerProduct(ip,x,x,&p);CHKERRQ(ierr);
+    if (PetscAbsScalar(p)<PETSC_MACHINE_EPSILON)
+      PetscInfo(ip,"Zero norm, either the vector is zero or a semi-inner product is being used\n");
 #if defined(PETSC_USE_COMPLEX)
-  if (PetscRealPart(p)<0.0 || PetscAbsReal(PetscImaginaryPart(p))>PETSC_MACHINE_EPSILON) 
-     SETERRQ(1,"IPNorm: The inner product is not well defined");
-  *norm = PetscSqrtScalar(PetscRealPart(p));
+    if (PetscRealPart(p)<0.0 || PetscAbsReal(PetscImaginaryPart(p))>PETSC_MACHINE_EPSILON) 
+       SETERRQ(1,"IPNorm: The inner product is not well defined");
+    *norm = PetscSqrtScalar(PetscRealPart(p));
 #else
-  if (p<0.0) SETERRQ(1,"IPNorm: The inner product is not well defined");
-  *norm = PetscSqrtScalar(p);
+    if (p<0.0) SETERRQ(1,"IPNorm: The inner product is not well defined");
+    *norm = PetscSqrtScalar(p);
 #endif
+  }
 
   PetscFunctionReturn(0);
 }
@@ -94,7 +96,11 @@
   PetscValidHeaderSpecific(x,VEC_COOKIE,2);
   PetscValidPointer(norm,3);
   
-  ierr = IPInnerProductBegin(ip,x,x,&p);CHKERRQ(ierr);
+  if (!ip->matrix && ip->bilinear_form == IPINNER_HERMITIAN) {
+    ierr = VecNormBegin(x,NORM_2,norm);CHKERRQ(ierr);
+  } else {
+    ierr = IPInnerProductBegin(ip,x,x,&p);CHKERRQ(ierr);
+  }
 
   PetscFunctionReturn(0);
 }
@@ -130,19 +136,22 @@
   PetscValidHeaderSpecific(x,VEC_COOKIE,2);
   PetscValidPointer(norm,3);
   
-  ierr = IPInnerProductEnd(ip,x,x,&p);CHKERRQ(ierr);
-
-  if (PetscAbsScalar(p)<PETSC_MACHINE_EPSILON)
-    PetscInfo(ip,"Zero norm, either the vector is zero or a semi-inner product is being used\n");
+  if (!ip->matrix && ip->bilinear_form == IPINNER_HERMITIAN) {
+    ierr = VecNormEnd(x,NORM_2,norm);CHKERRQ(ierr);
+  } else {
+    ierr = IPInnerProductEnd(ip,x,x,&p);CHKERRQ(ierr);
+    if (PetscAbsScalar(p)<PETSC_MACHINE_EPSILON)
+      PetscInfo(ip,"Zero norm, either the vector is zero or a semi-inner product is being used\n");
 
 #if defined(PETSC_USE_COMPLEX)
-  if (PetscRealPart(p)<0.0 || PetscAbsReal(PetscImaginaryPart(p))>PETSC_MACHINE_EPSILON) 
-     SETERRQ(1,"IPNorm: The inner product is not well defined");
-  *norm = PetscSqrtScalar(PetscRealPart(p));
+    if (PetscRealPart(p)<0.0 || PetscAbsReal(PetscImaginaryPart(p))>PETSC_MACHINE_EPSILON) 
+       SETERRQ(1,"IPNorm: The inner product is not well defined");
+    *norm = PetscSqrtScalar(PetscRealPart(p));
 #else
-  if (p<0.0) SETERRQ(1,"IPNorm: The inner product is not well defined");
-  *norm = PetscSqrtScalar(p);
+    if (p<0.0) SETERRQ(1,"IPNorm: The inner product is not well defined");
+    *norm = PetscSqrtScalar(p);
 #endif
+  }
 
   PetscFunctionReturn(0);
 }
Index: src/st/impls/sinvert/sinvert.c
diff -u src/st/impls/sinvert/sinvert.c:1.29 src/st/impls/sinvert/sinvert.c:1.29.4.1
--- src/st/impls/sinvert/sinvert.c:1.29	Thu May 31 17:05:04 2007
+++ src/st/impls/sinvert/sinvert.c	Mon Oct  1 12:39:43 2007
@@ -117,8 +117,8 @@
     ierr = KSPSetOperators(st->ksp,st->mat,st->mat,DIFFERENT_NONZERO_PATTERN);CHKERRQ(ierr);
     break;
   default:
-    ierr = MatDuplicate(st->A,MAT_COPY_VALUES,&st->mat);CHKERRQ(ierr);
     if (st->sigma != 0.0) {
+      ierr = MatDuplicate(st->A,MAT_COPY_VALUES,&st->mat);CHKERRQ(ierr);
       if (st->B) { 
         ierr = MatAXPY(st->mat,-st->sigma,st->B,st->str);CHKERRQ(ierr); 
       } else { 
Index: src/st/interface/stfunc.c
diff -u src/st/interface/stfunc.c:1.32 src/st/interface/stfunc.c:1.32.2.1
--- src/st/interface/stfunc.c:1.32	Fri Jun  1 15:13:24 2007
+++ src/st/interface/stfunc.c	Mon Mar  3 17:48:21 2008
@@ -137,7 +137,7 @@
   PetscValidPointer(newst,2);
   *newst = 0;
 
-  PetscHeaderCreate(st,_p_ST,struct _STOps,ST_COOKIE,-1,"ST",comm,STDestroy,STView);
+  ierr = PetscHeaderCreate(st,_p_ST,struct _STOps,ST_COOKIE,-1,"ST",comm,STDestroy,STView);CHKERRQ(ierr);
   st->bops->publish       = STPublish_Petsc;
   ierr = PetscMemzero(st->ops,sizeof(struct _STOps));CHKERRQ(ierr);
 
Index: src/st/interface/stsolve.c
diff -u src/st/interface/stsolve.c:1.46 src/st/interface/stsolve.c:1.46.4.1
--- src/st/interface/stsolve.c:1.46	Thu May 31 17:05:04 2007
+++ src/st/interface/stsolve.c	Wed Jan  9 11:57:07 2008
@@ -64,6 +64,9 @@
    Output Parameter:
 .  B - output matrix
 
+   Note:
+   The output matrix B must be destroyed after use.
+   
    Level: developer
 @*/
 PetscErrorCode STGetBilinearForm(ST st,Mat *B)
@@ -81,8 +84,13 @@
 #define __FUNCT__ "STGetBilinearForm_Default"
 PetscErrorCode STGetBilinearForm_Default(ST st,Mat *B)
 {
+  PetscErrorCode ierr;
+
   PetscFunctionBegin;
   *B = st->B;
+  if (*B) {
+    ierr =  PetscObjectReference((PetscObject)*B);CHKERRQ(ierr);
+  }
   PetscFunctionReturn(0);
 }
 
Index: src/svd/impls/cross/cross.c
diff -u src/svd/impls/cross/cross.c:1.9 src/svd/impls/cross/cross.c:1.9.2.1
--- src/svd/impls/cross/cross.c:1.9	Fri Jun  1 18:24:35 2007
+++ src/svd/impls/cross/cross.c	Thu Jul  5 13:03:48 2007
@@ -118,6 +118,7 @@
 
   ierr = EPSSetOperators(cross->eps,cross->mat,PETSC_NULL);CHKERRQ(ierr);
   ierr = EPSSetProblemType(cross->eps,EPS_HEP);CHKERRQ(ierr);
+  ierr = EPSSetWhichEigenpairs(cross->eps,svd->which == SVD_LARGEST ? EPS_LARGEST_REAL : EPS_SMALLEST_REAL);CHKERRQ(ierr);
   ierr = EPSSetDimensions(cross->eps,svd->nsv,svd->ncv);CHKERRQ(ierr);
   ierr = EPSSetTolerances(cross->eps,svd->tol,svd->max_it);CHKERRQ(ierr);
   ierr = EPSSetUp(cross->eps);CHKERRQ(ierr);
@@ -136,7 +137,6 @@
   PetscScalar    sigma;
   
   PetscFunctionBegin;
-  ierr = EPSSetWhichEigenpairs(cross->eps,svd->which == SVD_LARGEST ? EPS_LARGEST_REAL : EPS_SMALLEST_REAL);CHKERRQ(ierr);
   ierr = EPSSetInitialVector(cross->eps,svd->vec_initial);CHKERRQ(ierr);
   ierr = EPSSolve(cross->eps);CHKERRQ(ierr);
   ierr = EPSGetConverged(cross->eps,&svd->nconv);CHKERRQ(ierr);
Index: src/svd/impls/cyclic/cyclic.c
diff -u src/svd/impls/cyclic/cyclic.c:1.10 src/svd/impls/cyclic/cyclic.c:1.10.2.1
--- src/svd/impls/cyclic/cyclic.c:1.10	Fri Jun  1 18:24:35 2007
+++ src/svd/impls/cyclic/cyclic.c	Thu Jul  5 13:03:48 2007
@@ -133,6 +133,7 @@
 
   ierr = EPSSetOperators(cyclic->eps,cyclic->mat,PETSC_NULL);CHKERRQ(ierr);
   ierr = EPSSetProblemType(cyclic->eps,EPS_HEP);CHKERRQ(ierr);
+  ierr = EPSSetWhichEigenpairs(cyclic->eps,svd->which == SVD_LARGEST ? EPS_LARGEST_REAL : EPS_SMALLEST_MAGNITUDE);CHKERRQ(ierr);
   ierr = EPSSetDimensions(cyclic->eps,svd->nsv,svd->ncv);CHKERRQ(ierr);
   ierr = EPSSetTolerances(cyclic->eps,svd->tol,svd->max_it);CHKERRQ(ierr);
   ierr = EPSSetUp(cyclic->eps);CHKERRQ(ierr);
@@ -163,7 +164,6 @@
   VecScatter     vsU,vsV;
   
   PetscFunctionBegin;
-  ierr = EPSSetWhichEigenpairs(cyclic->eps,svd->which == SVD_LARGEST ? EPS_LARGEST_REAL : EPS_SMALLEST_MAGNITUDE);CHKERRQ(ierr);
   ierr = EPSSolve(cyclic->eps);CHKERRQ(ierr);
   ierr = EPSGetConverged(cyclic->eps,&svd->nconv);CHKERRQ(ierr);
   ierr = EPSGetIterationNumber(cyclic->eps,&svd->its);CHKERRQ(ierr);
Index: src/svd/interface/svdbasic.c
diff -u src/svd/interface/svdbasic.c:1.29 src/svd/interface/svdbasic.c:1.29.2.1
--- src/svd/interface/svdbasic.c:1.29	Fri Jun  1 16:29:14 2007
+++ src/svd/interface/svdbasic.c	Mon Mar  3 17:48:21 2008
@@ -189,7 +189,7 @@
   PetscFunctionBegin;
   PetscValidPointer(outsvd,2);
 
-  PetscHeaderCreate(svd,_p_SVD,struct _SVDOps,SVD_COOKIE,-1,"SVD",comm,SVDDestroy,SVDView);
+  ierr = PetscHeaderCreate(svd,_p_SVD,struct _SVDOps,SVD_COOKIE,-1,"SVD",comm,SVDDestroy,SVDView);CHKERRQ(ierr);
   *outsvd = svd;
 
   svd->bops->publish   = SVDPublish_Petsc;
Index: src/svd/interface/svdopts.c
diff -u src/svd/interface/svdopts.c:1.17 src/svd/interface/svdopts.c:1.17.4.1
--- src/svd/interface/svdopts.c:1.17	Thu May 31 17:05:04 2007
+++ src/svd/interface/svdopts.c	Thu Jul  5 13:03:48 2007
@@ -288,7 +288,10 @@
   switch (which) {
     case SVD_LARGEST:
     case SVD_SMALLEST:
-      svd->which = which;
+      if (svd->which != which) {
+        svd->setupcalled = 0;
+        svd->which = which;
+      }
       break;
   default:
     SETERRQ(PETSC_ERR_ARG_OUTOFRANGE,"Invalid 'which' parameter");    
Index: src/sys/ftn-custom/zslepc_start.c
diff -u src/sys/ftn-custom/zslepc_start.c:1.8 src/sys/ftn-custom/zslepc_start.c:1.8.4.1
--- src/sys/ftn-custom/zslepc_start.c:1.8	Thu May 31 17:05:04 2007
+++ src/sys/ftn-custom/zslepc_start.c	Thu Jul  5 13:03:48 2007
@@ -19,7 +19,7 @@
 
 extern PetscTruth SlepcBeganPetsc;
 
-static PetscTruth SlepcInitializeCalled=PETSC_FALSE;
+extern PetscTruth SlepcInitializeCalled;
 
 #ifdef PETSC_HAVE_FORTRAN_CAPS
 #define petscinitialize_              PETSCINITIALIZE
