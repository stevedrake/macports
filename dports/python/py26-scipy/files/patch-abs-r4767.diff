Index: /trunk/scipy/sparse/linalg/dsolve/SuperLU/SRC/scsum1.c
===================================================================
--- scipy/linsolve/SuperLU/SRC/scsum1.c (revision 960)
+++ scipy/linsolve/SuperLU/SRC/scsum1.c (revision 4767)
@@ -43,5 +43,5 @@
     float ret_val;
     /* Builtin functions */
-    double c_abs(complex *);
+    double slu_c_cabs(complex *);
     /* Local variables */
     static int i, nincx;
@@ -70,5 +70,5 @@
 /*        NEXT LINE MODIFIED. */
 
-	stemp += c_abs(&CX(i));
+	stemp += slu_c_cabs(&CX(i));
 /* L10: */
     }
@@ -84,5 +84,5 @@
 /*        NEXT LINE MODIFIED. */
 
-	stemp += c_abs(&CX(i));
+	stemp += slu_c_cabs(&CX(i));
 /* L30: */
     }
Index: /trunk/scipy/sparse/linalg/dsolve/SuperLU/SRC/cpivotgrowth.c
===================================================================
--- scipy/linsolve/SuperLU/SRC/cpivotgrowth.c (revision 960)
+++ scipy/linsolve/SuperLU/SRC/cpivotgrowth.c (revision 4767)
@@ -84,13 +84,13 @@
             oldcol = inv_perm_c[j];
 	    for (i = Astore->colptr[oldcol]; i < Astore->colptr[oldcol+1]; ++i)
-		maxaj = SUPERLU_MAX( maxaj, c_abs1( &Aval[i]) );
+		maxaj = SUPERLU_MAX( maxaj, slu_c_cabs1( &Aval[i]) );
 	
 	    maxuj = 0.;
 	    for (i = Ustore->colptr[j]; i < Ustore->colptr[j+1]; i++)
-		maxuj = SUPERLU_MAX( maxuj, c_abs1( &Uval[i]) );
+		maxuj = SUPERLU_MAX( maxuj, slu_c_cabs1( &Uval[i]) );
 	    
 	    /* Supernode */
 	    for (i = 0; i < nz_in_U; ++i)
-		maxuj = SUPERLU_MAX( maxuj, c_abs1( &luval[i]) );
+		maxuj = SUPERLU_MAX( maxuj, slu_c_cabs1( &luval[i]) );
 
 	    ++nz_in_U;
Index: /trunk/scipy/sparse/linalg/dsolve/SuperLU/SRC/cutil.c
===================================================================
--- scipy/linsolve/SuperLU/SRC/cutil.c (revision 960)
+++ scipy/linsolve/SuperLU/SRC/cutil.c (revision 4767)
@@ -415,6 +415,6 @@
       for (i = 0; i < X->nrow; i++) {
         c_sub(&temp, &soln_work[i], &xtrue[i]);
-	err = SUPERLU_MAX(err, c_abs(&temp));
-	xnorm = SUPERLU_MAX(xnorm, c_abs(&soln_work[i]));
+	err = SUPERLU_MAX(err, slu_c_cabs(&temp));
+	xnorm = SUPERLU_MAX(xnorm, slu_c_cabs(&soln_work[i]));
       }
       err = err / xnorm;
Index: /trunk/scipy/sparse/linalg/dsolve/SuperLU/SRC/clangs.c
===================================================================
--- scipy/linsolve/SuperLU/SRC/clangs.c (revision 960)
+++ scipy/linsolve/SuperLU/SRC/clangs.c (revision 4767)
@@ -73,5 +73,5 @@
 	for (j = 0; j < A->ncol; ++j)
 	    for (i = Astore->colptr[j]; i < Astore->colptr[j+1]; i++)
-		value = SUPERLU_MAX( value, c_abs( &Aval[i]) );
+		value = SUPERLU_MAX( value, slu_c_cabs( &Aval[i]) );
 	
     } else if (lsame_(norm, "O") || *(unsigned char *)norm == '1') {
@@ -81,5 +81,5 @@
 	    sum = 0.;
 	    for (i = Astore->colptr[j]; i < Astore->colptr[j+1]; i++) 
-		sum += c_abs( &Aval[i] );
+		sum += slu_c_cabs( &Aval[i] );
 	    value = SUPERLU_MAX(value,sum);
 	}
@@ -93,5 +93,5 @@
 	    for (i = Astore->colptr[j]; i < Astore->colptr[j+1]; i++) {
 		irow = Astore->rowind[i];
-		rwork[irow] += c_abs( &Aval[i] );
+		rwork[irow] += slu_c_cabs( &Aval[i] );
 	    }
 	value = 0.;
Index: /trunk/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsrfs.c
===================================================================
--- scipy/linsolve/SuperLU/SRC/cgsrfs.c (revision 960)
+++ scipy/linsolve/SuperLU/SRC/cgsrfs.c (revision 4767)
@@ -277,12 +277,12 @@
 	       numerator and denominator before dividing. */
 
-	    for (i = 0; i < A->nrow; ++i) rwork[i] = c_abs1( &Bptr[i] );
+	    for (i = 0; i < A->nrow; ++i) rwork[i] = slu_c_cabs1( &Bptr[i] );
 	    
 	    /* Compute abs(op(A))*abs(X) + abs(B). */
 	    if (notran) {
 		for (k = 0; k < A->ncol; ++k) {
-		    xk = c_abs1( &Xptr[k] );
+		    xk = slu_c_cabs1( &Xptr[k] );
 		    for (i = Astore->colptr[k]; i < Astore->colptr[k+1]; ++i)
-			rwork[Astore->rowind[i]] += c_abs1(&Aval[i]) * xk;
+			rwork[Astore->rowind[i]] += slu_c_cabs1(&Aval[i]) * xk;
 		}
 	    } else {
@@ -291,5 +291,5 @@
 		    for (i = Astore->colptr[k]; i < Astore->colptr[k+1]; ++i) {
 			irow = Astore->rowind[i];
-			s += c_abs1(&Aval[i]) * c_abs1(&Xptr[irow]);
+			s += slu_c_cabs1(&Aval[i]) * slu_c_cabs1(&Xptr[irow]);
 		    }
 		    rwork[k] += s;
@@ -299,7 +299,7 @@
 	    for (i = 0; i < A->nrow; ++i) {
 		if (rwork[i] > safe2)
-		    s = SUPERLU_MAX( s, c_abs1(&work[i]) / rwork[i] );
+		    s = SUPERLU_MAX( s, slu_c_cabs1(&work[i]) / rwork[i] );
 		else
-		    s = SUPERLU_MAX( s, (c_abs1(&work[i]) + safe1) / 
+		    s = SUPERLU_MAX( s, (slu_c_cabs1(&work[i]) + safe1) / 
 				(rwork[i] + safe1) );
 	    }
@@ -352,12 +352,12 @@
           where W = abs(R) + NZ*EPS*( abs(op(A))*abs(X)+abs(B) ))) */
 	
-	for (i = 0; i < A->nrow; ++i) rwork[i] = c_abs1( &Bptr[i] );
+	for (i = 0; i < A->nrow; ++i) rwork[i] = slu_c_cabs1( &Bptr[i] );
 	
 	/* Compute abs(op(A))*abs(X) + abs(B). */
 	if ( notran ) {
 	    for (k = 0; k < A->ncol; ++k) {
-		xk = c_abs1( &Xptr[k] );
+		xk = slu_c_cabs1( &Xptr[k] );
 		for (i = Astore->colptr[k]; i < Astore->colptr[k+1]; ++i)
-		    rwork[Astore->rowind[i]] += c_abs1(&Aval[i]) * xk;
+		    rwork[Astore->rowind[i]] += slu_c_cabs1(&Aval[i]) * xk;
 	    }
 	} else {
@@ -366,6 +366,6 @@
 		for (i = Astore->colptr[k]; i < Astore->colptr[k+1]; ++i) {
 		    irow = Astore->rowind[i];
-		    xk = c_abs1( &Xptr[irow] );
-		    s += c_abs1(&Aval[i]) * xk;
+		    xk = slu_c_cabs1( &Xptr[irow] );
+		    s += slu_c_cabs1(&Aval[i]) * xk;
 		}
 		rwork[k] += s;
@@ -375,7 +375,7 @@
 	for (i = 0; i < A->nrow; ++i)
 	    if (rwork[i] > safe2)
-		rwork[i] = c_abs(&work[i]) + (iwork[i]+1)*eps*rwork[i];
+		rwork[i] = slu_c_cabs(&work[i]) + (iwork[i]+1)*eps*rwork[i];
 	    else
-		rwork[i] = c_abs(&work[i])+(iwork[i]+1)*eps*rwork[i]+safe1;
+		rwork[i] = slu_c_cabs(&work[i])+(iwork[i]+1)*eps*rwork[i]+safe1;
 	kase = 0;
 
@@ -425,11 +425,11 @@
  	if ( notran && colequ ) {
 	    for (i = 0; i < A->nrow; ++i)
-	    	lstres = SUPERLU_MAX( lstres, C[i] * c_abs1( &Xptr[i]) );
+	    	lstres = SUPERLU_MAX( lstres, C[i] * slu_c_cabs1( &Xptr[i]) );
   	} else if ( !notran && rowequ ) {
 	    for (i = 0; i < A->nrow; ++i)
-	    	lstres = SUPERLU_MAX( lstres, R[i] * c_abs1( &Xptr[i]) );
+	    	lstres = SUPERLU_MAX( lstres, R[i] * slu_c_cabs1( &Xptr[i]) );
 	} else {
 	    for (i = 0; i < A->nrow; ++i)
-	    	lstres = SUPERLU_MAX( lstres, c_abs1( &Xptr[i]) );
+	    	lstres = SUPERLU_MAX( lstres, slu_c_cabs1( &Xptr[i]) );
 	}
 	if ( lstres != 0. )
Index: /trunk/scipy/sparse/linalg/dsolve/SuperLU/SRC/clacon.c
===================================================================
--- scipy/linsolve/SuperLU/SRC/clacon.c (revision 960)
+++ scipy/linsolve/SuperLU/SRC/clacon.c (revision 4767)
@@ -107,5 +107,5 @@
     if (*n == 1) {
 	v[0] = x[0];
-	*est = c_abs(&v[0]);
+	*est = slu_c_cabs(&v[0]);
 	/*        ... QUIT */
 	goto L150;
@@ -114,5 +114,5 @@
 
     for (i = 0; i < *n; ++i) {
-	d__1 = c_abs(&x[i]);
+	d__1 = slu_c_cabs(&x[i]);
 	if (d__1 > safmin) {
 	    d__1 = 1 / d__1;
@@ -159,5 +159,5 @@
 
     for (i = 0; i < *n; ++i) {
-	d__1 = c_abs(&x[i]);
+	d__1 = slu_c_cabs(&x[i]);
 	if (d__1 > safmin) {
 	    d__1 = 1 / d__1;
Index: /trunk/scipy/sparse/linalg/dsolve/SuperLU/SRC/cpivotL.c
===================================================================
--- scipy/linsolve/SuperLU/SRC/cpivotL.c (revision 960)
+++ scipy/linsolve/SuperLU/SRC/cpivotL.c (revision 4767)
@@ -107,5 +107,5 @@
     old_pivptr = nsupc;
     for (isub = nsupc; isub < nsupr; ++isub) {
-        rtemp = c_abs1 (&lu_col_ptr[isub]);
+        rtemp = slu_c_cabs1 (&lu_col_ptr[isub]);
 	if ( rtemp > pivmax ) {
 	    pivmax = rtemp;
@@ -128,5 +128,5 @@
     /* Choose appropriate pivotal element by our policy. */
     if ( *usepr ) {
-        rtemp = c_abs1 (&lu_col_ptr[old_pivptr]);
+        rtemp = slu_c_cabs1 (&lu_col_ptr[old_pivptr]);
 	if ( rtemp != 0.0 && rtemp >= thresh )
 	    pivptr = old_pivptr;
@@ -137,5 +137,5 @@
 	/* Use diagonal pivot? */
 	if ( diag >= 0 ) { /* diagonal exists */
-            rtemp = c_abs1 (&lu_col_ptr[diag]);
+            rtemp = slu_c_cabs1 (&lu_col_ptr[diag]);
 	    if ( rtemp != 0.0 && rtemp >= thresh ) pivptr = diag;
         }
Index: /trunk/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsequ.c
===================================================================
--- scipy/linsolve/SuperLU/SRC/cgsequ.c (revision 960)
+++ scipy/linsolve/SuperLU/SRC/cgsequ.c (revision 4767)
@@ -119,5 +119,5 @@
 	for (i = Astore->colptr[j]; i < Astore->colptr[j+1]; ++i) {
 	    irow = Astore->rowind[i];
-	    r[irow] = SUPERLU_MAX( r[irow], c_abs1(&Aval[i]) );
+	    r[irow] = SUPERLU_MAX( r[irow], slu_c_cabs1(&Aval[i]) );
 	}
 
@@ -154,5 +154,5 @@
 	for (i = Astore->colptr[j]; i < Astore->colptr[j+1]; ++i) {
 	    irow = Astore->rowind[i];
-	    c[j] = SUPERLU_MAX( c[j], c_abs1(&Aval[i]) * r[irow] );
+	    c[j] = SUPERLU_MAX( c[j], slu_c_cabs1(&Aval[i]) * r[irow] );
 	}
 
Index: /trunk/scipy/sparse/linalg/dsolve/SuperLU/SRC/scomplex.c
===================================================================
--- scipy/linsolve/SuperLU/SRC/scomplex.c (revision 960)
+++ scipy/linsolve/SuperLU/SRC/scomplex.c (revision 4767)
@@ -46,5 +46,5 @@
 
 /* Returns sqrt(z.r^2 + z.i^2) */
-double c_abs(complex *z)
+double slu_c_cabs(complex *z)
 {
     float temp;
@@ -69,5 +69,5 @@
 /* Approximates the abs */
 /* Returns abs(z.r) + abs(z.i) */
-double c_abs1(complex *z)
+double slu_c_cabs1(complex *z)
 {
     float real = z->r;
Index: /trunk/scipy/sparse/linalg/dsolve/SuperLU/SRC/scomplex.h
===================================================================
--- scipy/linsolve/SuperLU/SRC/scomplex.h (revision 967)
+++ scipy/linsolve/SuperLU/SRC/scomplex.h (revision 4767)
@@ -58,6 +58,6 @@
 /* Prototypes for functions in scomplex.c */
 void c_div(complex *, complex *, complex *);
-double c_abs(complex *);     /* exact */
-double c_abs1(complex *);    /* approximate */
+double slu_c_cabs(complex *);     /* exact */
+double slu_c_cabs1(complex *);    /* approximate */
 void c_exp(complex *, complex *);
 void r_cnjg(complex *, complex *);
