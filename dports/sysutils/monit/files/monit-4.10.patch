--- ../monit-4.9/process/sysdep_DARWIN.c	2007-01-04 08:02:07.000000000 +1100
+++ process/sysdep_DARWIN.c	2007-08-13 18:19:42.000000000 +1000
@@ -2,19 +2,18 @@
  * Copyright (C), 2000-2007 by the monit project group.
  * All Rights Reserved.
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- * 
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 
@@ -68,8 +67,9 @@
  *  @author Christian Hopp <chopp@iei.tu-clausthal.de>
  *  @author Rory Toma <rory@digeo.com>
  *  @author Martin Pala <martinp@tildeslash.com>
+ *  @author Dave Cheney <dcheney@redbubble.com> (Updated for Tiger)
  *
- *  @version \$Id: sysdep_DARWIN.c,v 1.31 2007/01/03 09:31:02 martinp Exp $
+ *  @version \$Id: sysdep_DARWIN.c,v 1.35 2007/08/13 08:19:42 hauk Exp $
  *
  *  @file
  */
@@ -143,46 +143,46 @@
 int initprocesstree_sysdep(ProcessTree_T **reference) {
   int                i;
   int                treesize;
-  static kvm_t      *kvm_handle;
+  mach_port_t        mytask = mach_task_self();
   struct kinfo_proc *pinfo;
   ProcessTree_T     *pt;
-
+  size_t             bufSize = 0;
+  int mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0 };
 
   if(getuid()!=0) {
     LogError("system statistic error -- permission denied\n");
     return FALSE;
   }
 
-  if(!(kvm_handle = kvm_open(NULL, NULL, NULL, O_RDONLY, "kvm_open: ")))
-  {
-    LogError("system statistic error -- cannot initialize kvm interface\n");
+  if(sysctl(mib, 4, NULL, &bufSize, NULL, 0) < 0) {
+    LogError("system statistic error -- sysctl failed");
     return FALSE;
   }
+  pinfo = (struct kinfo_proc *)xcalloc(1, bufSize);
 
-  pinfo = kvm_getprocs(kvm_handle, KERN_PROC_ALL, 0, &treesize);
-  if(!pinfo || (treesize < 1))
-  {
-    LogError("system statistic error -- cannot get process tree\n");
-    kvm_close(kvm_handle);
+  if(sysctl(mib, 4, pinfo, &bufSize, NULL, 0)) {
+    LogError("system statistic error -- sysctl failed");
+    free(pinfo);
     return FALSE;
   }
 
+  treesize = bufSize / sizeof(struct kinfo_proc);
+
   pt = xcalloc(sizeof(ProcessTree_T), treesize);
 
   for(i = 0; i < treesize; i++)
   {
     mach_port_t task;
 
-    pt[i].pid       = pinfo[i].kp_proc.p_pid;
-    pt[i].ppid      = pinfo[i].kp_eproc.e_ppid;
+    pt[i].pid  = pinfo[i].kp_proc.p_pid;
+    pt[i].ppid = pinfo[i].kp_eproc.e_ppid;
 
-    if(pinfo[i].kp_proc.p_stat == SZOMB)
-    {
+    if(pinfo[i].kp_proc.p_stat == SZOMB) {
       pt[i].status_flag |= PROCESS_ZOMBIE;
     }
     pt[i].time = get_float_time();
 
-    if(task_for_pid(mach_task_self(), pt[i].pid, &task) == KERN_SUCCESS) {
+    if(task_for_pid(mytask, pt[i].pid, &task) == KERN_SUCCESS) {
       mach_msg_type_number_t   count;
       task_basic_info_data_t   taskinfo;
       thread_array_t           threadtable;
@@ -197,24 +197,27 @@
                                (taskinfo.user_time.microseconds + taskinfo.system_time.microseconds) / 100000);
       }
       if(task_threads(task, &threadtable, &threadtable_size) == KERN_SUCCESS) {
-        int                      j;
+        int j;
 
         threadinfo = &threadinfo_data;
-        for (j = 0; j < threadtable_size; j++) {
-                count = THREAD_BASIC_INFO_COUNT;
-                if (thread_info(threadtable[j], THREAD_BASIC_INFO, (thread_info_t)threadinfo, &count) == KERN_SUCCESS) {
-                        if((threadinfo->flags & TH_FLAGS_IDLE) == 0) {
-                          pt[i].cputime += (long)((threadinfo->user_time.seconds      + threadinfo->system_time.seconds)      * 10     +
-                                                  (threadinfo->user_time.microseconds + threadinfo->system_time.microseconds) / 100000);
-                        }
-                }
+        for(j = 0; j < threadtable_size; j++) {
+          count = THREAD_BASIC_INFO_COUNT;
+          if(thread_info(threadtable[j], THREAD_BASIC_INFO, (thread_info_t)threadinfo, &count) == KERN_SUCCESS) {
+            if((threadinfo->flags & TH_FLAGS_IDLE) == 0) {
+              pt[i].cputime += (long)((threadinfo->user_time.seconds      + threadinfo->system_time.seconds)      * 10     +
+                                      (threadinfo->user_time.microseconds + threadinfo->system_time.microseconds) / 100000);
+            }
+          }
+          mach_port_deallocate(mytask, threadtable[j]);
         }
+		vm_deallocate(mytask, (vm_address_t)threadtable,threadtable_size * sizeof(thread_act_t));
       }
+      mach_port_deallocate(mytask, task); 	
     }
   }
 
   *reference = pt;
-  kvm_close(kvm_handle);
+  free(pinfo);
 
   return treesize;
 }
