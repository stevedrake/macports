? misc/fnmatch.c-DEBUG
? misc/glob.c-DEBUG
cvs server: Diffing misc
Index: misc/fnmatch.c
===================================================================
RCS file: /cvs/devel/rpm/misc/fnmatch.c,v
retrieving revision 1.7.2.2
diff -u -b -B -w -p -r1.7.2.2 fnmatch.c
--- misc/fnmatch.c	28 Jan 2005 06:36:29 -0000	1.7.2.2
+++ misc/fnmatch.c	3 Feb 2005 23:58:31 -0000
@@ -607,7 +607,7 @@ internal_fnmatch (const char *pattern, c
 
 
 int
-fnmatch (const char *pattern, const char *string, int flags)
+xxfnmatch (const char *pattern, const char *string, int flags)
 {
   return internal_fnmatch (pattern, string, flags & FNM_PERIOD, flags);
 }
Index: misc/fnmatch.h
===================================================================
RCS file: /cvs/devel/rpm/misc/fnmatch.h,v
retrieving revision 1.3.8.2
diff -u -b -B -w -p -r1.3.8.2 fnmatch.h
--- misc/fnmatch.h	28 Jan 2005 06:36:29 -0000	1.3.8.2
+++ misc/fnmatch.h	3 Feb 2005 23:58:32 -0000
@@ -75,7 +75,7 @@ extern "C" {
 
 /* Match NAME against the filename pattern PATTERN,
    returning zero if it matches, FNM_NOMATCH if not.  */
-extern int fnmatch __P ((__const char *__pattern, __const char *__name,
+extern int xxfnmatch __P ((__const char *__pattern, __const char *__name,
 			 int __flags));
 
 #ifdef	__cplusplus
Index: misc/glob.c
===================================================================
RCS file: /cvs/devel/rpm/misc/glob.c,v
retrieving revision 1.15.2.2
diff -u -b -B -w -p -r1.15.2.2 glob.c
--- misc/glob.c	28 Jan 2005 06:36:29 -0000	1.15.2.2
+++ misc/glob.c	3 Feb 2005 23:58:33 -0000
@@ -48,7 +48,7 @@
 
 # include <assert.h>
 
-#define	__alloca	alloca
+#define	__xxalloca	alloca
 #define	__stat		stat
 #define	NAMLEN(_d)	NLENGTH(_d)
 
@@ -130,7 +130,7 @@ static int __glob_pattern_p (const char 
    If memory cannot be allocated for PGLOB, GLOB_NOSPACE is returned.
    Otherwise, `glob' returns zero.  */
 int
-glob (const char *pattern, int flags,
+xxglob (const char *pattern, int flags,
 	int (*errfunc) __P ((const char *, int)), glob_t *pglob)
 {
   const char *filename;
@@ -165,7 +165,7 @@ glob (const char *pattern, int flags,
 	  if (onealt == NULL)
 	    {
 	      if (!(flags & GLOB_APPEND))
-		globfree (pglob);
+		xxglobfree (pglob);
 	      return GLOB_NOSPACE;
 	    }
 #endif
@@ -187,7 +187,7 @@ glob (const char *pattern, int flags,
 #ifndef __GNUC__
 	      free (onealt);
 #endif
-	      return glob (pattern, flags & ~GLOB_BRACE, errfunc, pglob);
+	      return xxglob (pattern, flags & ~GLOB_BRACE, errfunc, pglob);
 	    }
 
 	  /* Now find the end of the whole brace expression.  */
@@ -201,7 +201,7 @@ glob (const char *pattern, int flags,
 #ifndef __GNUC__
 		  free (onealt);
 #endif
-		  return glob (pattern, flags & ~GLOB_BRACE, errfunc, pglob);
+		  return xxglob (pattern, flags & ~GLOB_BRACE, errfunc, pglob);
 		}
 	    }
 	  /* Please note that we now can be sure the brace expression
@@ -236,7 +236,7 @@ glob (const char *pattern, int flags,
 	      memcpy (&alt_start[next - p], rest, rest_len);
 #endif
 
-	      result = glob (onealt,
+	      result = xxglob (onealt,
 			     ((flags & ~(GLOB_NOCHECK|GLOB_NOMAGIC))
 			      | GLOB_APPEND), errfunc, pglob);
 
@@ -247,7 +247,7 @@ glob (const char *pattern, int flags,
 		  free (onealt);
 #endif
 		  if (!(flags & GLOB_APPEND))
-		    globfree (pglob);
+		    xxglobfree (pglob);
 		  return result;
 		}
 
@@ -325,7 +325,7 @@ glob (const char *pattern, int flags,
 	  char *drive_spec;
 
 	  ++dirlen;
-	  drive_spec = (char *) __alloca (dirlen + 1);
+	  drive_spec = (char *) __xxalloca (dirlen + 1);
 #ifdef HAVE_MEMPCPY
 	  *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\0';
 #else
@@ -341,7 +341,7 @@ glob (const char *pattern, int flags,
 	     from "d:/", since "d:" and "d:/" are not the same.*/
 	}
 #endif
-      newp = (char *) __alloca (dirlen + 1);
+      newp = (char *) __xxalloca (dirlen + 1);
 #ifdef HAVE_MEMPCPY
       *((char *) mempcpy (newp, pattern, dirlen)) = '\0';
 #else
@@ -360,7 +360,7 @@ glob (const char *pattern, int flags,
 	  && dirlen > 1)
 	/* "pattern/".  Expand "pattern", appending slashes.  */
 	{
-	  int val = glob (dirname, flags | GLOB_MARK, errfunc, pglob);
+	  int val = xxglob (dirname, flags | GLOB_MARK, errfunc, pglob);
 	  if (val == 0)
 	    pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)
 			       | (flags & GLOB_MARK));
@@ -402,7 +402,7 @@ glob (const char *pattern, int flags,
 		/* `sysconf' does not support _SC_LOGIN_NAME_MAX.  Try
 		   a moderate value.  */
 		buflen = 20;
-	      name = (char *) __alloca (buflen);
+	      name = (char *) __xxalloca (buflen);
 
 	      success = getlogin_r (name, buflen) >= 0;
 #   else
@@ -421,7 +421,7 @@ glob (const char *pattern, int flags,
 		    /* `sysconf' does not support _SC_GETPW_R_SIZE_MAX.
 		       Try a moderate value.  */
 		    pwbuflen = 1024;
-		  pwtmpbuf = (char *) __alloca (pwbuflen);
+		  pwtmpbuf = (char *) __xxalloca (pwbuflen);
 
 		  while (getpwnam_r (name, &pwbuf, pwtmpbuf, pwbuflen, &p)
 			 != 0)
@@ -432,7 +432,7 @@ glob (const char *pattern, int flags,
 			  break;
 			}
 		      pwbuflen *= 2;
-		      pwtmpbuf = (char *) __alloca (pwbuflen);
+		      pwtmpbuf = (char *) __xxalloca (pwbuflen);
 		      __set_errno (save);
 		    }
 #   else
@@ -458,7 +458,7 @@ glob (const char *pattern, int flags,
 	    {
 	      char *newp;
 	      size_t home_len = strlen (home_dir);
-	      newp = (char *) __alloca (home_len + dirlen);
+	      newp = (char *) __xxalloca (home_len + dirlen);
 # ifdef HAVE_MEMPCPY
 	      mempcpy (mempcpy (newp, home_dir, home_len),
 		       &dirname[1], dirlen);
@@ -481,7 +481,7 @@ glob (const char *pattern, int flags,
 	  else
 	    {
 	      char *newp;
-	      newp = (char *) __alloca (end_name - dirname);
+	      newp = (char *) __xxalloca (end_name - dirname);
 # ifdef HAVE_MEMPCPY
 	      *((char *) mempcpy (newp, dirname + 1, end_name - dirname))
 		= '\0';
@@ -505,7 +505,7 @@ glob (const char *pattern, int flags,
 	      /* `sysconf' does not support _SC_GETPW_R_SIZE_MAX.  Try a
 		 moderate value.  */
 	      buflen = 1024;
-	    pwtmpbuf = (char *) __alloca (buflen);
+	    pwtmpbuf = (char *) __xxalloca (buflen);
 
 	    while (getpwnam_r (user_name, &pwbuf, pwtmpbuf, buflen, &p) != 0)
 	      {
@@ -515,7 +515,7 @@ glob (const char *pattern, int flags,
 		    break;
 		  }
 		buflen *= 2;
-		pwtmpbuf = __alloca (buflen);
+		pwtmpbuf = __xxalloca (buflen);
 		__set_errno (save);
 	      }
 #  else
@@ -532,7 +532,7 @@ glob (const char *pattern, int flags,
 	      char *newp;
 	      size_t home_len = strlen (home_dir);
 	      size_t rest_len = end_name == NULL ? 0 : strlen (end_name);
-	      newp = (char *) __alloca (home_len + rest_len + 1);
+	      newp = (char *) __xxalloca (home_len + rest_len + 1);
 #  ifdef HAVE_MEMPCPY
 	      *((char *) mempcpy (mempcpy (newp, home_dir, home_len),
 				  end_name, rest_len)) = '\0';
@@ -625,7 +625,7 @@ glob (const char *pattern, int flags,
 	  dirs.gl_lstat = pglob->gl_lstat;
 	}
 
-      status = glob (dirname,
+      status = xxglob (dirname,
 		     ((flags & (GLOB_ERR | GLOB_NOCHECK | GLOB_NOESCAPE
 				| GLOB_ALTDIRFUNC))
 		      | GLOB_NOSORT | GLOB_ONLYDIR),
@@ -647,8 +647,8 @@ glob (const char *pattern, int flags,
 
 	    if (interrupt_state)
 	      {
-		globfree (&dirs);
-		globfree (&files);
+		xxglobfree (&dirs);
+		xxglobfree (&files);
 		return GLOB_ABORTED;
 	      }
 	  }
@@ -665,8 +665,8 @@ glob (const char *pattern, int flags,
 
 	  if (status != 0)
 	    {
-	      globfree (&dirs);
-	      globfree (pglob);
+	      xxglobfree (&dirs);
+	      xxglobfree (pglob);
 	      return status;
 	    }
 
@@ -675,8 +675,8 @@ glob (const char *pattern, int flags,
 			    &pglob->gl_pathv[old_pathc],
 			    pglob->gl_pathc - old_pathc))
 	    {
-	      globfree (&dirs);
-	      globfree (pglob);
+	      xxglobfree (&dirs);
+	      xxglobfree (pglob);
 	      return GLOB_NOSPACE;
 	    }
 	}
@@ -706,7 +706,7 @@ glob (const char *pattern, int flags,
 				     sizeof (char *));
 	      if (pglob->gl_pathv == NULL)
 		{
-		  globfree (&dirs);
+		  xxglobfree (&dirs);
 		  return GLOB_NOSPACE;
 		}
 
@@ -730,8 +730,8 @@ glob (const char *pattern, int flags,
 							     + filename_len);
 		  if (pglob->gl_pathv[pglob->gl_pathc] == NULL)
 		    {
-		      globfree (&dirs);
-		      globfree (pglob);
+		      xxglobfree (&dirs);
+		      xxglobfree (pglob);
 		      return GLOB_NOSPACE;
 		    }
 
@@ -763,7 +763,7 @@ glob (const char *pattern, int flags,
 	    return GLOB_NOMATCH;
 	}
 
-      globfree (&dirs);
+      xxglobfree (&dirs);
     }
   else
     {
@@ -783,7 +783,7 @@ glob (const char *pattern, int flags,
 			    &pglob->gl_pathv[ignore],
 			    pglob->gl_pathc - ignore))
 	    {
-	      globfree (pglob);
+	      xxglobfree (pglob);
 	      return GLOB_NOSPACE;
 	    }
 	}
@@ -804,7 +804,7 @@ glob (const char *pattern, int flags,
 	    char *new = xrealloc (pglob->gl_pathv[i], len);
  	    if (new == NULL)
 	      {
-		globfree (pglob);
+		xxglobfree (pglob);
 		return GLOB_NOSPACE;
 	      }
 	    strcpy (&new[len - 2], "/");
@@ -831,7 +831,7 @@ glob (const char *pattern, int flags,
 
 /* Free storage allocated in PGLOB by a previous `glob' call.  */
 void
-globfree (glob_t *pglob)
+xxglobfree (glob_t *pglob)
 {
   if (pglob->gl_pathv != NULL)
     {
@@ -1001,7 +1001,7 @@ glob_in_dir (const char *pattern, const 
 	  struct stat st;
 	  size_t patlen = strlen (pattern);
 	  size_t dirlen = strlen (directory);
-	  char *fullname = (char *) __alloca (dirlen + 1 + patlen + 1);
+	  char *fullname = (char *) __xxalloca (dirlen + 1 + patlen + 1);
 
 # ifdef HAVE_MEMPCPY
 	  mempcpy (mempcpy (mempcpy (fullname, directory, dirlen),
@@ -1028,7 +1028,7 @@ glob_in_dir (const char *pattern, const 
 	{
 	  /* This is a special case for matching directories like in
 	     "*a/".  */
-	  names = (struct globlink *) __alloca (sizeof (struct globlink));
+	  names = (struct globlink *) __xxalloca (sizeof (struct globlink));
 	  names->name = (char *) xmalloc (1);
 	  if (names->name == NULL)
 	    goto memory_error;
@@ -1084,10 +1084,10 @@ glob_in_dir (const char *pattern, const 
 
 		  name = d->d_name;
 
-		  if (fnmatch (pattern, name, fnm_flags) == 0)
+		  if (xxfnmatch (pattern, name, fnm_flags) == 0)
 		    {
 		      struct globlink *new = (struct globlink *)
-			__alloca (sizeof (struct globlink));
+			__xxalloca (sizeof (struct globlink));
 		      len = NAMLEN (d);
 		      new->name = (char *) xmalloc (len + 1);
 		      if (new->name == NULL)
@@ -1112,7 +1112,7 @@ glob_in_dir (const char *pattern, const 
     {
       size_t len = strlen (pattern);
       nfound = 1;
-      names = (struct globlink *) __alloca (sizeof (struct globlink));
+      names = (struct globlink *) __xxalloca (sizeof (struct globlink));
       names->next = NULL;
       names->name = (char *) xmalloc (len + 1);
       if (names->name == NULL)
Index: misc/glob.h
===================================================================
RCS file: /cvs/devel/rpm/misc/glob.h,v
retrieving revision 1.6.16.3
diff -u -b -B -w -p -r1.6.16.3 glob.h
--- misc/glob.h	28 Jan 2005 06:36:29 -0000	1.6.16.3
+++ misc/glob.h	3 Feb 2005 23:58:33 -0000
@@ -152,12 +152,12 @@ typedef struct
    If memory cannot be allocated for PGLOB, GLOB_NOSPACE is returned.
    Otherwise, `glob' returns zero.  */
 #if _FILE_OFFSET_BITS != 64
-extern int glob __P ((__const char *__pattern, int __flags,
+extern int xxglob __P ((__const char *__pattern, int __flags,
 		      int (*__errfunc) (__const char *, int),
 		      glob_t *__pglob));
 
 /* Free storage allocated in PGLOB by a previous `glob' call.  */
-extern void globfree __P ((glob_t *__pglob));
+extern void xxglobfree __P ((glob_t *__pglob));
 #else
 # if __GNUC__ >= 2
 extern int glob __P ((__const char *__pattern, int __flags,
cvs server: Diffing rpmio
Index: rpmio/rpmrpc.c
===================================================================
RCS file: /cvs/devel/rpm/rpmio/rpmrpc.c,v
retrieving revision 2.44.2.4
diff -u -b -B -w -p -r2.44.2.4 rpmrpc.c
--- rpmio/rpmrpc.c	28 Jan 2005 06:36:33 -0000	2.44.2.4
+++ rpmio/rpmrpc.c	3 Feb 2005 23:58:33 -0000
@@ -1466,14 +1466,14 @@ fprintf(stderr, "*** Glob(%s,0x%x,%p,%p)
 	return -2;
 	/*@notreached@*/ break;
     }
-    return glob(pattern, flags, errfunc, pglob);
+    return xxglob(pattern, flags, errfunc, pglob);
 }
 
 void Globfree(glob_t *pglob)
 {
 if (_rpmio_debug)
 fprintf(stderr, "*** Globfree(%p)\n", pglob);
-    globfree(pglob);
+    xxglobfree(pglob);
 }
 
 DIR * Opendir(const char * path)
Index: rpmio/stubs.c
===================================================================
RCS file: /cvs/devel/rpm/rpmio/stubs.c,v
retrieving revision 1.5.6.1
diff -u -b -B -w -p -r1.5.6.1 stubs.c
--- rpmio/stubs.c	28 Jan 2005 06:36:33 -0000	1.5.6.1
+++ rpmio/stubs.c	3 Feb 2005 23:58:33 -0000
@@ -71,8 +71,6 @@
 #endif
 
 #if defined(USE_GNU_GLOB)
-#include "misc/fnmatch.h"
 #include "misc/fnmatch.c"
-#include "misc/glob.h"
 #include "misc/glob.c"
 #endif
cvs server: Diffing rpmio/sexp
cvs server: Diffing rpmio/sexp/tests
