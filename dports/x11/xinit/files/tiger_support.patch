diff --git Makefile.am Makefile.am
index 78ae154..0d831f3 100644
--- Makefile.am
+++ Makefile.am
@@ -67,9 +67,6 @@ endif
 
 DIST_SUBDIRS = privileged_startx
 
-xinitrc: xinitrc.cpp Makefile
-startx: startx.cpp Makefile
-
 xinitrc_DATA = xinitrc
 
 CLEANFILES = xinitrc startx $(appman_DATA) $(launchagents_DATA)
diff --git configure.ac configure.ac
index 2d09cad..86bd1f2 100644
--- configure.ac
+++ configure.ac
@@ -102,18 +102,17 @@ AC_ARG_WITH(launchdaemons-dir,  AS_HELP_STRING([--with-launchdaemons-dir=PATH],
 
 if test "x$LAUNCHD" = "xauto"; then
 	unset LAUNCHD
-	case $host_os in
-		darwin8*)
-			LAUNCHD=no
-		;;
-		*)
-			AC_CHECK_PROG(LAUNCHD, [launchd], [yes], [no])
-		;;
-	esac
+	AC_CHECK_PROG(LAUNCHD, [launchd], [yes], [no])
 fi
 
+TIGER_LAUNCHD=no
 if test "x$LAUNCHD" = "xyes" ; then
 	AC_DEFINE(HAVE_LAUNCHD, 1, [launchd support available])
+	case $host_os in
+		darwin8*)
+			TIGER_LAUNCHD=yes
+		;;
+	esac
 else
         launchagentsdir=""
         launchdaemonsdir=""
@@ -121,6 +120,7 @@ fi
 AC_SUBST([launchagentsdir])
 AC_SUBST([launchdaemonsdir])
 AM_CONDITIONAL(LAUNCHD, [test "x$LAUNCHD" = "xyes"])
+AM_CONDITIONAL(TIGER_LAUNCHD, [test "x$TIGER_LAUNCHD" = "xyes"])
 
 # Checks for pkg-config packages
 PKG_CHECK_MODULES(XINIT, x11)
diff --git org.x.startx.plist.cpp org.x.startx.plist.cpp
index 42c9f70..4bcedcf 100644
--- org.x.startx.plist.cpp
+++ org.x.startx.plist.cpp
@@ -21,5 +21,7 @@
 		</dict>
 	<key>ServiceIPC</key>
 		<true/>
+	<key>EnableTransactions</key>
+		<true/>
 </dict>
 </plist>
diff --git privileged_startx/20-font_cache.cpp privileged_startx/20-font_cache.cpp
index c13384b..6d43e10 100755
--- privileged_startx/20-font_cache.cpp
+++ privileged_startx/20-font_cache.cpp
@@ -27,9 +27,9 @@ XCOMM promote the sale, use or other dealings in this Software without
 XCOMM prior written authorization.
 
 if [ -x BINDIR/font_cache ] ; then
-	BINDIR/font_cache &
+	BINDIR/font_cache -s &
 elif [ -x BINDIR/font_cache.sh ] ; then
 	BINDIR/font_cache.sh -s &
-elif [ -x /usr/X11/bin/fc-cache ] ; then
+elif [ -x BINDIR/fc-cache ] ; then
 	BINDIR/fc-cache &
 fi
diff --git privileged_startx/Makefile.am privileged_startx/Makefile.am
index 6a143ca..2d68544 100644
--- privileged_startx/Makefile.am
+++ privileged_startx/Makefile.am
@@ -34,9 +34,12 @@ xinitrc_PROGRAMS = privileged_startx
 privstartx_SCRIPTS = 10-tmpdirs 20-font_cache
 
 AM_CPPFLAGS = -DXINITDIR=\"$(xinitrcdir)\" -DSCRIPTDIR=\"$(privstartxdir)\" -DBINDIR=\"$(bindir)\"
-
 CPP_FILES_FLAGS = -DXINITDIR="$(xinitrcdir)" -DSCRIPTDIR="$(privstartxdir)" -DBINDIR="$(bindir)"
 
+if TIGER_LAUNCHD
+CPP_FILES_FLAGS += -DTIGER_LAUNCHD
+endif
+
 dist_privileged_startx_SOURCES = \
 	server.c \
 	client.c \
@@ -70,5 +73,5 @@ EXTRA_DIST = \
 	privileged_startx.defs \
 	privileged_startx_types.h
 
-$(BUILT_SOURCES): privileged_startx.defs
-	mig -sheader privileged_startxServer.h privileged_startx.defs
+$(BUILT_SOURCES): $(srcdir)/privileged_startx.defs
+	mig -sheader privileged_startxServer.h $(srcdir)/privileged_startx.defs
diff --git privileged_startx/client.c privileged_startx/client.c
index 2a24a70..a33dd02 100644
--- privileged_startx/client.c
+++ privileged_startx/client.c
@@ -34,6 +34,8 @@
 #include <stdlib.h>
 #include <stdbool.h>
 
+#include <AvailabilityMacros.h>
+
 #include "privileged_startx.h"
 
 int client_main(void) {
@@ -42,7 +44,11 @@ int client_main(void) {
     
     kr = bootstrap_look_up(bootstrap_port, BOOTSTRAP_NAME, &mp);
     if (kr != KERN_SUCCESS) {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
         fprintf(stderr, "bootstrap_look_up(): %s\n", bootstrap_strerror(kr));
+#else
+        fprintf(stderr, "bootstrap_look_up(): %ul\n", (unsigned long)kr);
+#endif
         exit(EXIT_FAILURE);
     }
     
diff --git privileged_startx/org.x.privileged_startx.plist.cpp privileged_startx/org.x.privileged_startx.plist.cpp
index e878dc3..7400cc4 100644
--- privileged_startx/org.x.privileged_startx.plist.cpp
+++ privileged_startx/org.x.privileged_startx.plist.cpp
@@ -4,18 +4,25 @@
 <dict>
 	<key>Label</key>
 		<string>org.x.privileged_startx</string>
-	<key>MachServices</key>
-		<dict>
-			<key>org.x.privileged_startx</key>
-				<true/>
-		</dict>
 	<key>ProgramArguments</key>
 		<array>
 			<string>XINITDIR/privileged_startx</string>
 			<string>-d</string>
 			<string>SCRIPTDIR</string>
 		</array>
+#ifdef TIGER_LAUNCHD
+	<key>KeepAlive</key>
+		<true/>
+#else
+	<key>MachServices</key>
+		<dict>
+			<key>org.x.privileged_startx</key>
+				<true/>
+		</dict>
 	<key>TimeOut</key>
-		<integer>60</integer>
+		<integer>120</integer>
+	<key>EnableTransactions</key>
+		<true/>
+#endif
 </dict>
 </plist>
diff --git privileged_startx/server.c privileged_startx/server.c
index 7afd424..6dd4f2b 100644
--- privileged_startx/server.c
+++ privileged_startx/server.c
@@ -40,7 +40,6 @@
 #include <sys/time.h>
 #include <launch.h>
 #include <asl.h>
-#include <pthread.h>
 #include <errno.h>
 
 #include "privileged_startx.h"
@@ -51,6 +50,10 @@ union MaxMsgSize {
     union __ReplyUnion__privileged_startx_subsystem rep; 
 };
 
+#ifdef LAUNCH_JOBKEY_MACHSERVICES
+#include <pthread.h>
+static void* idle_thread(void* param __attribute__((unused)));
+
 /* globals to trigger idle exit */
 #define DEFAULT_IDLE_TIMEOUT 60 /* 60 second timeout, then the server exits */
 
@@ -61,6 +64,7 @@ struct idle_globals {
 };
 
 struct idle_globals idle_globals;
+#endif
 
 #ifndef SCRIPTDIR
 #define SCRIPTDIR="/usr/X11/lib/X11/xinit/privileged_startx.d"
@@ -69,13 +73,46 @@ struct idle_globals idle_globals;
 /* Default script dir */
 const char *script_dir = SCRIPTDIR;
 
-static void* idle_thread(void* param __attribute__((unused)));
+#ifndef LAUNCH_JOBKEY_MACHSERVICES
+static mach_port_t checkin_or_register(char *bname) {
+    kern_return_t kr;
+    mach_port_t mp;
+    
+    /* If we're started by launchd or the old mach_init */
+    kr = bootstrap_check_in(bootstrap_port, bname, &mp);
+    if (kr == KERN_SUCCESS)
+        return mp;
+    
+    /* We probably were not started by launchd or the old mach_init */
+    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &mp);
+    if (kr != KERN_SUCCESS) {
+        fprintf(stderr, "mach_port_allocate(): %s\n", mach_error_string(kr));
+        exit(EXIT_FAILURE);
+    }
+    
+    kr = mach_port_insert_right(mach_task_self(), mp, mp, MACH_MSG_TYPE_MAKE_SEND);
+    if (kr != KERN_SUCCESS) {
+        fprintf(stderr, "mach_port_insert_right(): %s\n", mach_error_string(kr));
+        exit(EXIT_FAILURE);
+    }
+    
+    kr = bootstrap_register(bootstrap_port, bname, mp);
+    if (kr != KERN_SUCCESS) {
+        fprintf(stderr, "bootstrap_register(): %s\n", mach_error_string(kr));
+        exit(EXIT_FAILURE);
+    }
+    
+    return mp;
+}
+#endif
 
 int server_main(const char *dir) {
     mach_msg_size_t mxmsgsz = sizeof(union MaxMsgSize) + MAX_TRAILER_SIZE;
     mach_port_t mp;
     kern_return_t kr;
+#ifdef LAUNCH_JOBKEY_MACHSERVICES
     long idle_timeout = DEFAULT_IDLE_TIMEOUT;
+#endif
 
     launch_data_t config = NULL, checkin = NULL;
     checkin = launch_data_new_string(LAUNCH_KEY_CHECKIN);
@@ -85,6 +122,13 @@ int server_main(const char *dir) {
         exit(EXIT_FAILURE);
     }
 
+    if(dir) {
+        script_dir = dir;
+        asl_log(NULL, NULL, ASL_LEVEL_DEBUG,
+                "script directory set: %s", script_dir);
+    }
+
+#ifdef LAUNCH_JOBKEY_MACHSERVICES
     launch_data_t tmv;
     tmv = launch_data_dict_lookup(config, LAUNCH_JOBKEY_TIMEOUT);
     if (tmv) {
@@ -93,12 +137,6 @@ int server_main(const char *dir) {
                 "idle timeout set: %ld seconds", idle_timeout);
     }
 
-    if(dir) {
-        script_dir = dir;
-        asl_log(NULL, NULL, ASL_LEVEL_DEBUG,
-                "script directory set: %s", script_dir);
-    }
-
     launch_data_t svc;
     svc = launch_data_dict_lookup(config, LAUNCH_JOBKEY_MACHSERVICES);
     if (!svc) {
@@ -114,6 +152,10 @@ int server_main(const char *dir) {
     }
 
     mp = launch_data_get_machport(svc);
+#else
+    mp = checkin_or_register("org.x.privileged_startx");
+#endif
+
     if (mp == MACH_PORT_NULL) {
         asl_log(NULL, NULL, ASL_LEVEL_ERR, "NULL mach service: %s",
                 BOOTSTRAP_NAME);
@@ -129,12 +171,14 @@ int server_main(const char *dir) {
         exit(EXIT_FAILURE);
     }
 
+#ifdef LAUNCH_JOBKEY_MACHSERVICES
     /* spawn a thread to monitor our idle timeout */
     pthread_t thread;
     idle_globals.mp = mp;
     idle_globals.timeout = idle_timeout;
     gettimeofday(&idle_globals.lastmsg, NULL);
     pthread_create(&thread, NULL, &idle_thread, NULL);
+#endif
 
     /* Main event loop */
     kr = mach_msg_server(privileged_startx_server, mxmsgsz, mp, 0);
@@ -161,8 +205,10 @@ kern_return_t do_privileged_startx(mach_port_t test_port __attribute__((unused))
 
     const char * path_argv[2] = {script_dir, NULL};
 
+#ifdef LAUNCH_JOBKEY_MACHSERVICES
     /* Store that we were called, so the idle timer will reset */
     gettimeofday(&idle_globals.lastmsg, NULL);
+#endif
 
     /* script_dir contains a set of files to run with root privs when X11 starts */
     ftsp = fts_open(path_argv, FTS_PHYSICAL, ftscmp);
@@ -222,6 +268,7 @@ kern_return_t do_privileged_startx(mach_port_t test_port __attribute__((unused))
 }
 
 kern_return_t do_idle_exit(mach_port_t test_port __attribute__((unused))) {
+#ifdef LAUNCH_JOBKEY_MACHSERVICES
     struct timeval now;
     gettimeofday(&now, NULL);
 
@@ -231,8 +278,12 @@ kern_return_t do_idle_exit(mach_port_t test_port __attribute__((unused))) {
     }
 
     return KERN_SUCCESS;
+#else
+    return KERN_FAILURE;
+#endif
 }
 
+#ifdef LAUNCH_JOBKEY_MACHSERVICES
 static void *idle_thread(void* param __attribute__((unused))) {
     for(;;) {
         struct timeval now;
@@ -248,3 +299,4 @@ static void *idle_thread(void* param __attribute__((unused))) {
     }
     return NULL;
 }
+#endif
diff --git startx.cpp startx.cpp
index 8ffdc70..fb23f18 100644
--- startx.cpp
+++ startx.cpp
@@ -84,21 +84,25 @@ serverargs=""
 
 #ifdef __APPLE__
 
+if [ "x$X11_PREFS_DOMAIN" = x ] ; then
+    X11_PREFS_DOMAIN="org.x.X11"
+fi
+
 XCOMM Initialize defaults (this will cut down on "safe" error messages)
-if ! defaults read org.x.X11 cache_fonts >& /dev/null ; then
-    defaults write org.x.X11 cache_fonts -bool true
+if ! defaults read $X11_PREFS_DOMAIN cache_fonts >& /dev/null ; then
+    defaults write $X11_PREFS_DOMAIN cache_fonts -bool true
 fi
 
-if ! defaults read org.x.X11 no_auth >& /dev/null ; then
-    defaults write org.x.X11 no_auth -bool false
+if ! defaults read $X11_PREFS_DOMAIN no_auth >& /dev/null ; then
+    defaults write $X11_PREFS_DOMAIN no_auth -bool false
 fi
 
-if ! defaults read org.x.X11 nolisten_tcp >& /dev/null ; then
-    defaults write org.x.X11 nolisten_tcp -bool true
+if ! defaults read $X11_PREFS_DOMAIN nolisten_tcp >& /dev/null ; then
+    defaults write $X11_PREFS_DOMAIN nolisten_tcp -bool true
 fi
 
 XCOMM First, start caching fonts
-if [ x`defaults read org.x.X11 cache_fonts` = x1 ] ; then
+if [ x`defaults read $X11_PREFS_DOMAIN cache_fonts` = x1 ] ; then
     if [ -x /usr/X11/bin/font_cache ] ; then
         /usr/X11/bin/font_cache &
     elif [ -x /usr/X11/bin/font_cache.sh ] ; then
@@ -114,13 +118,13 @@ if [ -x XINITDIR/privileged_startx ] ; then
 	XINITDIR/privileged_startx
 fi
 
-if [ x`defaults read org.x.X11 no_auth` = x0 ] ; then
+if [ x`defaults read $X11_PREFS_DOMAIN no_auth` = x0 ] ; then
     enable_xauth=1
 else
     enable_xauth=0
 fi
 
-if [ x`defaults read org.x.X11 nolisten_tcp` = x1 ] ; then
+if [ x`defaults read $X11_PREFS_DOMAIN nolisten_tcp` = x1 ] ; then
     defaultserverargs="$defaultserverargs -nolisten tcp"
 fi
 
@@ -133,19 +137,6 @@ defaultdisplay=":$d"
 enable_xauth=1
 #endif
 
-
-if [ -f $userclientrc ]; then
-    defaultclientargs=$userclientrc
-elif [ -f $sysclientrc ]; then
-    defaultclientargs=$sysclientrc
-#if defined(__SCO__) || defined(__UNIXWARE__)
-elif [ -f $scouserclientrc ]; then
-    defaultclientargs=$scouserclientrc
-elif [ -f $scosysclientrc ]; then
-    defaultclientargs=$scosysclientrc
-#endif
-fi
-
 #if defined(__SCO__) || defined(__UNIXWARE__)
 
 XCOMM SCO -t option: do not start an X server
@@ -202,11 +193,23 @@ done
 
 XCOMM process client arguments
 if [ x"$client" = x ]; then
+    client=$defaultclient
+
     XCOMM if no client arguments either, use rc file instead
     if [ x"$clientargs" = x ]; then
-	client="$defaultclientargs"
-    else
-	client=$defaultclient
+        if [ -f "$userclientrc" ]; then
+            client=$userclientrc
+        elif [ -f "$sysclientrc" ]; then
+            client=$sysclientrc
+#if defined(__SCO__) || defined(__UNIXWARE__)
+        elif [ -f "$scouserclientrc" ]; then
+            client=$scouserclientrc
+        elif [ -f "$scosysclientrc" ]; then
+            client=$scosysclientrc
+#endif
+        fi
+
+        clientargs=$defaultclientargs
     fi
 fi
 
@@ -217,9 +220,9 @@ if [ x"$server" = x ]; then
     XCOMM if no server arguments or display either, use defaults
     if [ x"$serverargs" = x -a x"$display" = x ]; then
 	XCOMM For compatibility reasons, only use xserverrc if there were no server command line arguments
-	if [ -f $userserverrc ]; then
+	if [ -f "$userserverrc" ]; then
 	    server=$userserverrc
-	elif [ -f $sysserverrc ]; then
+	elif [ -f "$sysserverrc" ]; then
 	    server=$sysserverrc
 	fi
 
@@ -268,11 +271,15 @@ if [ x"$enable_xauth" = x1 ] ; then
 
     XCOMM create a file with auth information for the server. ':0' is a dummy.
     xserverauthfile=$HOME/.serverauth.$$
-    trap "rm -f $xserverauthfile" HUP INT QUIT ILL TRAP KILL BUS TERM
-    xauth -q -f $xserverauthfile << EOF
+    trap "rm -f '$xserverauthfile'" HUP INT QUIT ILL TRAP KILL BUS TERM
+    xauth -q -f "$xserverauthfile" << EOF
 add :$dummy . $mcookie
 EOF
+#ifdef __APPLE__
+    serverargs=${serverargs}" -auth '"${xserverauthfile}"'"
+#else
     serverargs=${serverargs}" -auth "${xserverauthfile}
+#endif
 
     XCOMM now add the same credentials to the client authority file
     XCOMM if '$displayname' already exists do not overwrite it as another
@@ -287,7 +294,7 @@ EOF
         removelist="$displayname $removelist"
         else
             dummy=$(($dummy+1));
-            XAUTH -q -f $xserverauthfile << EOF
+            XAUTH -q -f "$xserverauthfile" << EOF
 add :$dummy . $authcookie
 EOF
         fi
@@ -298,10 +305,16 @@ fi
 if [ "$REMOTE_SERVER" = "TRUE" ]; then
         exec SHELL_CMD ${client}
 else
-        XINIT $client $clientargs -- $server $display $serverargs
+        XINIT "$client" $clientargs -- "$server" $display $serverargs
 fi
 #else
-XINIT $client $clientargs -- $server $display $serverargs
+
+#ifdef __APPLE__
+eval XINIT \"$client\" $clientargs -- \"$server\" $display $serverargs
+#else
+XINIT "$client" $clientargs -- "$server" $display $serverargs
+#endif
+
 #endif
 
 if [ x"$enable_xauth" = x1 ] ; then
@@ -309,7 +322,7 @@ if [ x"$enable_xauth" = x1 ] ; then
         XAUTH remove $removelist
     fi
     if [ x"$xserverauthfile" != x ]; then
-        rm -f $xserverauthfile
+        rm -f "$xserverauthfile"
     fi
 fi
 
diff --git xinit.c xinit.c
index 523cfd5..d25de9d 100644
--- xinit.c
+++ xinit.c
@@ -60,6 +60,13 @@ in this Software without prior written authorization from The Open Group.
 #include <setjmp.h>
 #include <stdarg.h>
 
+#ifdef __APPLE__
+#include <AvailabilityMacros.h>
+#if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
+#include <vproc.h>
+#endif
+#endif
+
 #if !defined(SIGCHLD) && defined(SIGCLD)
 #define SIGCHLD SIGCLD
 #endif
@@ -250,6 +257,11 @@ main(int argc, char *argv[], char *envp[])
 	int client_args_given = 0, server_args_given = 0;
 	int start_of_client_args, start_of_server_args;
 	struct sigaction sa;
+#ifdef __APPLE__
+#if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
+	vproc_transaction_t vt;
+#endif
+#endif
 
 #ifdef __UNIXOS2__
 	envsave = envp;	/* circumvent an EMX problem */
@@ -426,6 +438,13 @@ main(int argc, char *argv[], char *envp[])
 
 	signal(SIGALRM, sigAlarm);
 	signal(SIGUSR1, sigUsr1);
+
+#ifdef __APPLE__
+#if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
+	vt = vproc_transaction_begin(NULL);
+#endif
+#endif
+
 	if (startServer(server) > 0
 	 && startClient(client) > 0) {
 		pid = -1;
@@ -434,6 +453,13 @@ main(int argc, char *argv[], char *envp[])
 			)
 			pid = wait(NULL);
 	}
+
+#ifdef __APPLE__
+#if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
+	vproc_transaction_end(NULL, vt);
+#endif
+#endif
+
 	signal(SIGTERM, SIG_IGN);
 	signal(SIGQUIT, SIG_IGN);
 	signal(SIGINT, SIG_IGN);
@@ -464,15 +490,23 @@ waitforserver(void)
 	int	ncycles	 = 120;		/* # of cycles to wait */
 	int	cycles;			/* Wait cycle count */
 
+#ifdef __APPLE__
+	/* For Apple, we don't get signaled by the server when it's ready, so we just
+	 * want to sleep now since we're going to sleep later anyways and this allows us
+	 * to avoid the awkard, "why is there an error message in the log" questions
+	 * from users.
+         */
+
+	sleep(2);
+#endif
+
 	for (cycles = 0; cycles < ncycles; cycles++) {
 		if ((xd = XOpenDisplay(displayNum))) {
 			return(TRUE);
 		}
 		else {
-#define MSG "X server to begin accepting connections"
-		    if (!processTimeout (1, MSG)) 
+		    if (!processTimeout (1, "X server to begin accepting connections")) 
 		      break;
-#undef MSG
 		}
 	}
 
